<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://choyunsig.github.io/algorithm_with_boj/feed.xml" rel="self" type="application/atom+xml" /><link href="https://choyunsig.github.io/algorithm_with_boj/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-07-01T02:12:35+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/feed.xml</id><title type="html">APSwBT</title><subtitle>Algorithm blog written by CHOYUNSIG</subtitle><author><name>CHOYUNSIG</name></author><entry><title type="html">유량 그래프와 최대 유량</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow.html" rel="alternate" type="text/html" title="유량 그래프와 최대 유량" /><published>2024-02-01T00:00:00+00:00</published><updated>2024-02-01T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow.html"><![CDATA[<h2 id="소개">소개</h2>

<p>유량 그래프란 간선에 유량이라는 속성이 있는 그래프이다. 유량은 우리가 생각하는 수도관 파이프로 비유해 이해하면 쉽다. 다음과 같은 그래프에서 모든 간선을 물이 흐르는 파이프이며 모든 정점은 단지 여러 파이프의 연결부라고 생각하자. 간선에 쓰여있는 수들은 해당 간선에 시간당 한 번에 흐를 수 있는 물의 최대 용량(Capacity)이다. 유량 그래프에서 간선에는 방향이 있을 수도 있고 없을 수도 있다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #888">5</p> --&gt; B
    A -- <p style="color: #888">5</p> --&gt; C
    B -- <p style="color: #888">3</p> --&gt; D
    B -- <p style="color: #888">2</p> --&gt; E
    C -- <p style="color: #888">3</p> --&gt; E
    D -- <p style="color: #888">5</p> --&gt; F
    E -- <p style="color: #888">5</p> --&gt; F

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
</pre>

<p>정점 $\text A$가 이 그래프에 물을 공급하는 소스(Source)라고 한다면 정점 $\text F$는 최종적으로 물이 모이는 싱크(Sink)가 된다. 유량 그래프에서 흐르는 물을 흔히 유량(Flow)이라고 표현한다. 이 글에서도 그래프에 흐르는 물을 유량이라고 표현하겠다. 이 유량은 각 라우터 간의 트래픽 볼륨으로도 비유할 수 있다. 그래서 유량 그래프는 네트워크 분야에서 흔히 사용된다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #F00">1/5</p> --&gt; B
    A -- <p style="color: #888">0/5</p> --&gt; C
    B -- <p style="color: #888">0/3</p> --&gt; D
    B -- <p style="color: #F00">1/2</p> --&gt; E
    C -- <p style="color: #888">0/3</p> --&gt; E
    D -- <p style="color: #888">0/5</p> --&gt; F
    E -- <p style="color: #F00">1/5</p> --&gt; F

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
</pre>

<p>만약 정점 $\text A$에 시간당 1 만큼의 유량이 나온다면 정점 $\text F$에는 시간당 얼마만큼의 유량이 쏟아질까? 간선의 용량들이 여유로우므로 당연히 1 만큼의 유량이 모두 정점 $\text F$에 도달한다. 위의 그림은 정점 $\text A$에서 $\text F$로 1의 유량이 흐르는 한 예시이다. 꼭 현실 세계처럼 모든 파이프에 잔잔하게 유량이 흐르지 않아도 되며 유량이 다음 속성을 지키기만 한다면 어떠한 경로든 유량을 흘려도 괜찮다.</p>

<ol>
  <li>유한성: 간선의 유량은 반드시 간선의 용량보다 작거나 같다. 즉 간선의 용량에서 간선의 유량을 뺀 값은 항상 0보다 크거나 같다.</li>
  <li>대칭성: $u$에서 $v$로 유량 $f$이 흐르는 것은 $v$에서 $u$로 유량 $-f$이 흐르는 것과 같다.</li>
  <li>보존성: 소스와 싱크를 제외한 모든 정점에서 들어온 유량의 합과 나가는 유량의 합이 같다.</li>
</ol>

<p>특히 대칭성은 나중에 설명할 최대 유량 문제를 푸는 데 유용하게 쓰이는 성질이다.</p>

<h3 id="구현">구현</h3>

<p>유량 그래프를 구현해보자. 각 간선과 정점을 객체로 만들고 외부 클래스로 감쌌다. 아래 구현은 객체지향적 구현으로 성능을 중시하는 구현과는 거리가 멀다는 것을 참고하기 바란다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="c1"># 간선
</span>    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 간선에 연결된 노드를 반환
</span>        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># 간선의 잔여 용량을 반환
</span>        <span class="k">def</span> <span class="nf">get_remain</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>
        
        <span class="c1"># 간선에 유량을 흘림
</span>        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>
    
    <span class="c1"># 정점
</span>    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 생성자, 그래프의 크기와 소스 및 싱크를 입력받음
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">source</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">sink</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span>

    <span class="c1"># 두 정점을 간선으로 이음
</span>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
</code></pre></div></div>

<p>여기서 간선의 구현에 주목하자. 간선의 각 함수들인 <code class="language-plaintext highlighter-rouge">get_node</code>, <code class="language-plaintext highlighter-rouge">get_remain</code>, <code class="language-plaintext highlighter-rouge">give_flow</code>는 호출 시 인자로 받은 정점에 따라 해당 간선의 정보를 다르게 계산하고 있다. 왜냐하면 유량의 대칭성에 의해 간선의 시작점 방향에서 바라봤을 때와 간선의 도착점 방향에서 바라봤을 때의 간선의 잔여 용량이 다르기 때문이다. 이는 최대 유량 문제의 해결에서 더 자세히 다룬다.</p>

<h2 id="최대-유량-문제">최대 유량 문제</h2>

<p>여기서 다음과 같은 문제를 생각해 볼 수 있다. 만약 정점 $\text A$에 시간당 무한대의 유량이 나온다면 정점 $\text F$에는 시간당 얼만큼의 유량이 도달하게 될까? 간선이 허용하는 용량 선에서 정점 $\text F$에 유량이 도달할 것은 분명하다. 직접 그림을 그려 계산해보면 다음과 같이 정점 $\text F$에는 최대 8의 유량이 닿는다는 것을 볼 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #888">5/5</p> --&gt; B
    A -- <p style="color: #888">3/5</p> --&gt; C
    B -- <p style="color: #888">3/3</p> --&gt; D
    B -- <p style="color: #888">2/2</p> --&gt; E
    C -- <p style="color: #888">3/3</p> --&gt; E
    D -- <p style="color: #888">3/5</p> --&gt; F
    E -- <p style="color: #888">5/5</p> --&gt; F

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
</pre>

<p>이처럼 유량 그래프의 소스에서 무한대의 유량이 나온다고 가정했을 때 싱크에 도달할 수 있는 최대 유량을 구하는 문제를 최대 유량 문제라고 한다. 어떠한 유량 그래프가 주어졌을 때 싱크로 흐르는 최대 유량을 구할 때 고려해야 할 사항이 엄청 많아 보인다. 임의의 유량 그래프에서 최대 유량 문제를 어떻게 해결할 수 있을까?</p>

<h3 id="포드-풀커슨">포드-풀커슨</h3>

<p>해결법은 그래프에 유량이 더 이상 흐를 수 없을때까지 유량을 소량씩 흘려보내는 것을 반복하는 것이다. 즉, 다음과 같은 절차를 반복한다.</p>

<ol>
  <li>용량이 남아있는 간선을 따라 소스부터 싱크까지 가는 증가 경로(augmenting path)를 찾는다. 찾지 못할 경우 종료한다.</li>
  <li>찾은 경로를 따라 흘릴 수 있는 최대의 유량을 흘린다.</li>
</ol>

<p>아래 예시를 통해 이해해보자. 다음과 같이 정점 $\text A$가 소스, 정점 $\text D$가 싱크인 유량 그래프가 있다. 우리는 눈으로 간단히 이 그래프의 최대 유량이 10임을 알 수 있다. 과연 그 해답이 위 절차를 반복함으로서 도출되는 지 알아보자.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">0/5</p> .-&gt; B
    B -. <p style="color: #888">0/2</p> .-&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -. <p style="color: #888">0/5</p> .-&gt; D
    C -. <p style="color: #888">0/5</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>위 유량 그래프에서 증가 경로를 다음과 같이 찾을 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #888">0/5</p> --&gt; B
    B -- <p style="color: #888">0/2</p> --&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -. <p style="color: #888">0/5</p> .-&gt; D
    C -- <p style="color: #888">0/5</p> --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>찾은 경로에 유량을 흘린다. 위 경로를 통해 최대로 흘릴 수 있는 유량이 2이므로 2의 유량을 흘려준다.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #F00">2/5</p> .-&gt; B
    B -. <p style="color: #F00">2/2</p> .-&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -. <p style="color: #888">0/5</p> .-&gt; D
    C -. <p style="color: #F00">2/5</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 다시 증가 경로를 찾는 단계로 되돌아간다. 이러한 단계를 더 이상 증가 경로가 보이지 않을때까지 반복한다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #F00">5/5</p> --&gt; B
    B -. <p style="color: #888">2/2</p> .-&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -- <p style="color: #F00">3/5</p> --&gt; D
    C -. <p style="color: #888">2/5</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>
<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">5/5</p> .-&gt; B
    B -. <p style="color: #888">2/2</p> .-&gt; C
    A -- <p style="color: #F00">3/5</p> --&gt; C
    B -. <p style="color: #888">3/5</p> .-&gt; D
    C -- <p style="color: #F00">5/5</p> --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 위 그래프에서 증가 경로를 찾을 수 있는가? 우리 눈에는 증가 경로를 찾을 수 없지만 분명 이 그래프의 최대 유량이 8이 아닌 10이라는 것은 알고 있다. 그렇다면 숨겨진 증가 경로가 있는 것일까? 그렇다. 이는 유량의 대칭성을 이용하면 된다. 우선 각 간선들의 반대 방향으로 용량이 0인 간선을 추가로 그어준다. 이와 같은 간선이 유량 그래프의 최대 유량에 영향을 미치지 않음은 직관적으로 알 수 있다. 이제 유량의 대칭성에 의해 유량을 흘려준 간선의 반대 방향으로 같은 양의 음의 유량을 흘려 주었다고 생각하고 다시 그래프를 그려보자.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">정방향: 5/5\n<span style="color: #00F">역방향: -5/0</span></p> .-&gt; B
    B -. <p style="color: #888">정방향: 2/2\n<span style="color: #00F">역방향: -2/0</span></p> .-&gt; C
    A -. <p style="color: #888">정방향: 3/5\n<span style="color: #00F">역방향: -3/0</span></p> .-&gt; C
    B -. <p style="color: #888">정방향: 3/5\n<span style="color: #00F">역방향: -3/0</span></p> .-&gt; D
    C -. <p style="color: #888">정방향: 5/5\n<span style="color: #00F">역방향: -5/0</span></p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 증가 경로가 보일 것이다. 다음과 같은 경로는 간선의 잔여 용량, 즉 간선의 총 용량에서 현재 흐르고 있는 유량을 뺀 값이 양수인 간선만을 이용해 소스에서 싱크로 가고 있으므로 증가 경로라고 할 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; B
    B -- <p style="color: #888">정방향: 2/2\n<span style="color: #F00">역방향: -2/0</span></p> --&gt; C
    A -- <p style="color: #888"><span style="color: #F00">정방향: 3/5</span>\n역방향: -3/0</p> --&gt; C
    B -- <p style="color: #888"><span style="color: #F00">정방향: 3/5</span>\n역방향: -3/0</p> --&gt; D
    C -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 유량을 흘려준다.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; B
    B -. <p style="color: #F00">정방향: 0/2\n역방향: 0/0</p> .-&gt; C
    A -. <p style="color: #F00">정방향: 5/5\n역방향: -5/0</p> .-&gt; C
    B -. <p style="color: #F00">정방향: 5/5\n역방향: -5/0</p> .-&gt; D
    C -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 더 이상 증가 경로를 찾을 수 없으므로 종료가 된다. 종료가 되고 나면 이 그래프의 최대 유량이 10이라는 것을 알 수 있다. 이렇듯 유량의 대칭성을 이용해 숨겨진 증가 경로까지 전부 찾아내어 더 이상 유량이 흐를 수 없을때까지 그래프를 포화시켰을 때의 유량이 해당 그래프의 최대 유량이다. 이러한 방법을 포드-풀커슨 방법이라고 한다.</p>

<h4 id="구현-1">구현</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">count</span>

<span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_residual</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>

        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>

    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span> <span class="ow">is</span> <span class="n">sink</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">min_residual</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="n">residual</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_residual</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="ow">and</span> <span class="n">residual</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span>
                    <span class="n">flow</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">edge</span><span class="p">.</span><span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">flow</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ford_fulkerson</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">flow</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">Graph</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">],</span> <span class="n">INF</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">flow</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>포드-풀커슨 방법의 시간복잡도는 간선이 가질 수 있는 용량의 범위에 비례해 영향을 받는다. 왜냐하면 매번 흘리는 유량의 값이 최소 1이므로 최대 $F$번의 DFS 탐색이 필요하기 때문이다. 따라서 그래프의 정점의 개수를 $V$, 간선의 개수를 $E$, 간선 용량의 최댓값 $F$라 하면 포드-풀커슨 방법의 시간복잡도는 $O((V + E)F)$이다.</p>

<h4 id="에드몬드-카프">에드몬드-카프</h4>

<p>에드몬드-카프 알고리즘은 포드-풀커슨 방법의 일종이며 기존 포드-풀커슨 방법과 다른 점은 DFS 대신 BFS를 사용하여 간선이 적은 그래프에서 빠르게 작동한다는 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_residual</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>

        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>

    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visited_by</span><span class="p">:</span> <span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">min_residual</span> <span class="o">=</span> <span class="n">INF</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">edmonds_karp</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">]])</span>
            <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">Graph</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">now</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="n">residual</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_residual</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span> <span class="ow">and</span> <span class="n">residual</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">visited_by</span> <span class="o">=</span> <span class="n">edge</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">min_residual</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">now</span><span class="p">.</span><span class="n">min_residual</span><span class="p">)</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">min_residual</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">now</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">visited_by</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                <span class="n">now</span><span class="p">.</span><span class="n">visited_by</span><span class="p">.</span><span class="nf">give_flow</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">min_residual</span><span class="p">)</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">pre</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>에드몬드-카프 알고리즘은 정점의 개수가 $V$, 간선의 개수가 $E$인 그래프에서 BFS의 횟수가 많아야 $VE$번이라는 것이 증명되어 있다. 따라서 에드몬드-카프 알고리즘의 시간복잡도는 $O(VE^2)$이다.</p>

<h3 id="디닉">디닉</h3>

<p>디닉 알고리즘은 최대 유량을 레벨 그래프(Level Graph)의 개념을 적용하여 빠르게 구하는 알고리즘이다. 레벨 그래프란 각 정점에 잔여 용량이 있는 간선만을 이용해 BFS를 수행할 때 방문 깊이를 구하고, 잔여 용량이 남아있으면서 깊이가 1만큼 차이나는 정점을 잇는 간선만을 남겨놓은 그래프이다. 다음 예제로 디닉 알고리즘의 작동 절차를 설명하겠다. 이 예시는 <a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm">영문 위키피디아</a> 자료를 그대로 가져온 것이며 디닉 알고리즘을 설명할 때 아주 많이 쓰인다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Dinic_algorithm_G1.svg/1920px-Dinic_algorithm_G1.svg.png" style="background-color: white" /></p>

<p>우선 레벨 그래프를 구축한다. 즉, 잔여 용량이 남은 간선을 이용해 BFS를 수행하면서 정점마다 방문 깊이를 저장하고 깊이가 1만큼 차이나는 정점을 잇는 간선만을 남겨둔다. 그 후 이 그래프를 특화된 DFS를 이용해 소스부터 싱크까지의 경로를 찾고 유량을 흘려준다. 이 떄 흘려준 유량을 차단 유량(Blocking Flow)이라고 한다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/Dinic_algorithm_GL1.svg/1920px-Dinic_algorithm_GL1.svg.png" style="background-color: white" /></p>

<p>이것이 디닉 알고리즘의 한 단계이다. 한 단계를 끝마친 후 그래프의 모습은 아래와 같다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Dinic_algorithm_G2.svg/1920px-Dinic_algorithm_G2.svg.png" style="background-color: white" /></p>

<p>한 단계를 더 수행해본다. 즉, 다시 레벨 그래프를 구축하고 차단 유량을 흘린다. 아래 레벨 그래프 그림은 잔여 용량을 간선의 원래 용량처럼 보고 레벨 그래프를 그린 것이다.</p>

<div style="column-count: 2; margin-bottom: 16px">
    <img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Dinic_algorithm_GL2.svg/1920px-Dinic_algorithm_GL2.svg.png" style="background-color: white" />
    <img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Dinic_algorithm_G3.svg/1920px-Dinic_algorithm_G3.svg.png" style="background-color: white" />
</div>

<p>한 단계를 더 반복해 레벨 그래프를 구축하면 다음과 같이 더 이상 싱크까지 레벨 그래프를 구축할 수 없다. 이렇게 되면 디닉 알고리즘은 끝이 난다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Dinic_algorithm_GL3.svg/1920px-Dinic_algorithm_GL3.svg.png" style="background-color: white" /></p>

<p>디닉 알고리즘은 정점의 개수가 $V$, 간선의 개수가 $E$인 그래프에서 최대 $O(V)$번의 단계가 시행될 수 있으며, 각 단계에서 차단 유량을 찾는 데 걸리는 시간복잡도가 $O(VE)$임이 알려져 있다. 따라서 디닉 알고리즘의 시간복잡도는 $O(V^2E)$이다.</p>

<h4 id="구현-2">구현</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_remain</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>

        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>

    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span> <span class="ow">is</span> <span class="n">sink</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">min_residual</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pivot</span><span class="p">:]:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="n">remain</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_remain</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">flow</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">remain</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">edge</span><span class="p">.</span><span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">flow</span>
                <span class="n">self</span><span class="p">.</span><span class="n">pivot</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dinic</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">Graph</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">]])</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">now</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="n">remain</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_remain</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">flow</span><span class="p">:</span>
                <span class="n">flow</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">],</span> <span class="n">INF</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">flow</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="그래프_이론(graphs)" /><category term="최대_유량(flow)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">Heavy-Light 분할</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/31/hld.html" rel="alternate" type="text/html" title="Heavy-Light 분할" /><published>2024-01-31T00:00:00+00:00</published><updated>2024-01-31T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/31/hld</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/31/hld.html"><![CDATA[<h2 id="소개">소개</h2>

<h3 id="문제-제시">문제 제시</h3>

<p>모든 정점에 각각의 가중치가 있고 이 가중치가 수시로 바뀌는 트리가 있다. 이 트리의 임의의 두 정점 사이의 단순 경로에 있는 모든 정점의 가중치의 합을 구하는 프로그램을 만들고 싶다. 두 정점 간의 모든 정점을 DFS로 탐색하면서 더하면 $O(N)$의 시간이 걸릴 것이다. 이를 더욱 빠르게 수행하도록 만들 수 있겠는가?</p>

<h3 id="트리-분할">트리 분할</h3>

<p>이를 빠르게 해결하는 방법 중 하나는 사전에 트리의 구역을 잘게 분할해 놓는 것이다. 그 중 Heavy-Light 분할은 간선들을 “무거운 간선”과 “가벼운 간선”으로 나누어 놓고 무거운 간선들로 연결된 정점들끼리 하나의 구역으로 묶어 관리하는 기법이다. 무거운 간선들끼리 묶어 관리할 경우 트리의 임의의 두 정점 간의 단순 경로에 걸쳐있는 모든 구역의 개수가 $O(\log N)$에 비례하게 되어 더욱 빠른 쿼리 처리가 가능해진다.</p>

<h2 id="원리">원리</h2>

<p>무거운 간선은 다음 관계가 성립하는 정점 $u$와 $v$를 잇는 간선으로 정의하며, 가벼운 간선은 무거운 간선이 아닌 간선으로 정의한다.</p>

<blockquote>
  <p>$v$는 $u$의 자식들 중 서브 트리의 크기가 최댓값이면서 가장 왼쪽에 있는 정점이다.</p>
</blockquote>

<p>아래 트리의 간선들 중 무거운 간선와 가벼운 간선들을 분류해보자. 분류하기 쉽도록 정점들의 서브 트리의 크기를 전부 써 놓았다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B1 --&gt; C3
    B2 --&gt; C4
    B2 --&gt; C5
    C2 --&gt; D1
    C2 --&gt; D2
    C3 --&gt; D3

    A((<div style="width: 20px">11</div>))
    B1((<div style="width: 20px">7</div>))
    B2((<div style="width: 20px">3</div>))
    C1((<div style="width: 20px">1</div>))
    C2((<div style="width: 20px">3</div>))
    C3((<div style="width: 20px">2</div>))
    C4((<div style="width: 20px">1</div>))
    C5((<div style="width: 20px">1</div>))
    D1((<div style="width: 20px">1</div>))
    D2((<div style="width: 20px">1</div>))
    D3((<div style="width: 20px">1</div>))
</pre>

<p>위 트리에서 무거운 간선은 실선으로 나타내고 가벼운 간선들은 점선으로 나타내보자.</p>

<pre class="mermaid">
    graph TD

    A ==&gt; B1
    A -.-&gt; B2
    B1 -.-&gt; C1
    B1 ==&gt; C2
    B1 -.-&gt; C3
    B2 ==&gt; C4
    B2 -.-&gt; C5
    C2 ==&gt; D1
    C2 -.-&gt; D2
    C3 ==&gt; D3

    A((<div style="width: 20px">11</div>))
    B1((<div style="width: 20px">7</div>))
    B2((<div style="width: 20px">3</div>))
    C1((<div style="width: 20px">1</div>))
    C2((<div style="width: 20px">3</div>))
    C3((<div style="width: 20px">2</div>))
    C4((<div style="width: 20px">1</div>))
    C5((<div style="width: 20px">1</div>))
    D1((<div style="width: 20px">1</div>))
    D2((<div style="width: 20px">1</div>))
    D3((<div style="width: 20px">1</div>))
</pre>

<p>여기서 생각해 볼 것이 있다. 임의의 두 정점의 단순 경로에 포함된 가벼운 간선의 개수의 최댓값은 얼마일까? 어떤 정점에서 계속해서 가벼운 간선을 선택하면서 후손 정점로 간다고 해보자. 가벼운 간선을 선택하면서 전진할 경우 서브 트리의 크기는 절반 이하로 계속해서 줄어들게 될 것이다. 왜냐하면 연결된 자식의 서브 트리 크기가 본인의 절반을 넘어선다면 무조건 무거운 간선으로 연결될 수밖에 없기 때문이다. 따라서 어떠한 정점에서 후손 정점까지의 단순 경로에 포함된 가벼운 간선의 개수의 최댓값은 $O(\log N)$에 비례하며 임의의 두 정점의 단순 경로에 포함된 가벼운 간선의 개수의 최댓값도 $O(\log N)$에 비례한다. 이해가 끝났다면 이제 무거운 간선으로 이어진 정점들끼리 같은 색으로 표시해보자.</p>

<pre class="mermaid">
    graph TD

    A ==&gt; B1
    A -.-&gt; B2
    B1 -.-&gt; C1
    B1 ==&gt; C2
    B1 -.-&gt; C3
    B2 ==&gt; C4
    B2 -.-&gt; C5
    C2 ==&gt; D1
    C2 -.-&gt; D2
    C3 ==&gt; D3

    A((<div style="width: 20px"></div>)):::red
    B1((<div style="width: 20px"></div>)):::red
    B2((<div style="width: 20px"></div>)):::green
    C1((<div style="width: 20px"></div>)):::yellow
    C2((<div style="width: 20px"></div>)):::red
    C3((<div style="width: 20px"></div>)):::magenta
    C4((<div style="width: 20px"></div>)):::green
    C5((<div style="width: 20px"></div>)):::cyan
    D1((<div style="width: 20px"></div>)):::red
    D2((<div style="width: 20px"></div>)):::blue
    D3((<div style="width: 20px"></div>)):::magenta

    classDef red stroke:#F00, fill:#F00
    classDef green stroke:#0F0, fill:#0F0
    classDef blue stroke:#00F, fill:#00F
    classDef magenta stroke:#F0F, fill:#F0F
    classDef cyan stroke:#0FF, fill:#0FF
    classDef yellow stroke:#FF0, fill:#FF0
</pre>

<p>같은 색깔의 정점들은 같은 구역에 속하는 것으로 본다. 이제 트리를 구역별로 재배치해보자.</p>

<pre class="mermaid">
    graph TD

    A ==&gt; B1
    B1 ==&gt; C2
    B2 ==&gt; C4
    C2 ==&gt; D1
    C3 ==&gt; D3

    빨강 -.-&gt; 초록
    빨강 -.-&gt; 노랑
    빨강 -.-&gt; 보라
    빨강 -.-&gt; 파랑
    초록 -.-&gt; 청록

    A((<div style="width: 20px"></div>)):::red
    B1((<div style="width: 20px"></div>)):::red
    B2((<div style="width: 20px"></div>)):::green
    C1((<div style="width: 20px"></div>)):::yellow
    C2((<div style="width: 20px"></div>)):::red
    C3((<div style="width: 20px"></div>)):::magenta
    C4((<div style="width: 20px"></div>)):::green
    C5((<div style="width: 20px"></div>)):::cyan
    D1((<div style="width: 20px"></div>)):::red
    D2((<div style="width: 20px"></div>)):::blue
    D3((<div style="width: 20px"></div>)):::magenta

    subgraph 빨강
        direction LR
        A
        B1
        C2
        D1
    end

    subgraph 초록
        direction LR
        B2
        C4
    end

    subgraph 파랑
        direction LR
        D2
    end

    subgraph 노랑
        direction LR
        C1
    end

    subgraph 보라
        direction LR
        C3
        D3
    end

    subgraph 청록
        direction LR
        C5
    end

    classDef red stroke:#F00, fill:#F00
    classDef green stroke:#0F0, fill:#0F0
    classDef blue stroke:#00F, fill:#00F
    classDef magenta stroke:#F0F, fill:#F0F
    classDef cyan stroke:#0FF, fill:#0FF
    classDef yellow stroke:#FF0, fill:#FF0
</pre>

<p>이렇게 하면 Heavy-Light 분할이 끝난 것이다. 이렇게 분할한 구역들은 세 가지 특징이 있다.</p>

<ol>
  <li>구역들도 하나의 트리를 이룬다. 즉, 최소 공통 조상을 이용해 임의의 두 구역 간의 경로를 찾을 수 있다.</li>
  <li>각 구역들은 항상 가벼운 간선으로 이어져 있다. 즉, 임의의 두 구역의 거리가 $\log N$을 넘어서지 않는다.</li>
  <li>한 구역에는 이웃한 정점들이 일렬로 들어가 있다. 즉, 한 구역을 세그먼트 트리로 관리할 수 있다.</li>
</ol>

<p>위 특징들로 인해 임의의 두 정점 사이의 단순 경로상의 모든 정점들에 대한 쿼리를 빠르게 처리할 수 있다. 아래 예시로 이해해보자.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B1 --&gt; C3
    B2 --&gt; C4
    B2 --&gt; C5
    C2 --&gt; D1
    C2 --&gt; D2
    C3 --&gt; D3

    A((<div style="width: 20px"></div>))
    B1((<div style="width: 20px"></div>))
    B2((<div style="width: 20px"></div>))
    C1((<div style="width: 20px"></div>))
    C2((<div style="width: 20px"></div>))
    C3((<div style="width: 20px"></div>))
    C4((<div style="width: 20px"></div>))
    C5((<div style="width: 20px">B</div>)):::red
    D1((<div style="width: 20px"></div>))
    D2((<div style="width: 20px"></div>))
    D3((<div style="width: 20px">A</div>)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>위 그림에서 정점 $\text A$와 $\text B$ 사이의 단순 경로에 속한 정점들을 분할해놓은 구역에서 모두 표시해보자.</p>

<pre class="mermaid">
    graph TD

    A ==&gt; B1
    B1 ==&gt; C2
    B2 ==&gt; C4
    C2 ==&gt; D1
    C3 ==&gt; D3

    빨강 -.-&gt; 초록
    빨강 -.-&gt; 노랑
    빨강 -.-&gt; 보라
    빨강 -.-&gt; 파랑
    초록 -.-&gt; 청록

    A((<div style="width: 20px">fa:fa-check</div>)):::red
    B1((<div style="width: 20px">fa:fa-check</div>)):::red
    B2((<div style="width: 20px">fa:fa-check</div>)):::green
    C1((<div style="width: 20px"></div>)):::yellow
    C2((<div style="width: 20px"></div>)):::red
    C3((<div style="width: 20px">fa:fa-check</div>)):::magenta
    C4((<div style="width: 20px"></div>)):::green
    C5((<div style="width: 20px">fa:fa-check</div>)):::cyan
    D1((<div style="width: 20px"></div>)):::red
    D2((<div style="width: 20px"></div>)):::blue
    D3((<div style="width: 20px">fa:fa-check</div>)):::magenta

    subgraph 빨강
        direction LR
        A
        B1
        C2
        D1
    end

    subgraph 초록
        direction LR
        B2
        C4
    end

    subgraph 파랑
        direction LR
        D2
    end

    subgraph 노랑
        direction LR
        C1
    end

    subgraph 보라
        direction LR
        C3
        D3
    end

    subgraph 청록
        direction LR
        C5
    end

    classDef red stroke:#F00, fill:#F00
    classDef green stroke:#0F0, fill:#0F0
    classDef blue stroke:#00F, fill:#00F
    classDef magenta stroke:#F0F, fill:#F0F
    classDef cyan stroke:#0FF, fill:#0FF
    classDef yellow stroke:#FF0, fill:#FF0
</pre>

<p>위와 같이 경로 상의 모든 정점이 구역 안에서 서로 이어져 있어 세그먼트 트리를 적용하기 쉬워진다. 경로 상의 정점이 속한 모든 구역들은 위 트리 상에서도 하나의 경로를 이루므로 두 정점이 속한 각각의 구역에서부터 최소 공통 조상까지 거슬러 올라가며 각 구간에 접근하도록 만들면 된다. 두 정점 간의 경로를 처리하기 위해 방문해야 하는 구역의 개수가 $O(\log N)$개이므로 각 구간에서의 처리 연산의 시간복잡도를 $O(T(N))$이라고 한다면 Heavy-Light 분할이 진행된 트리에서 임의의 두 정점 간의 경로 상에서의 쿼리를 $O(T(N)\log N)$의 시간만에 해결할 수 있다.</p>

<h2 id="구현">구현</h2>

<p>이제 Heavy-Light 분할을 이용해 임의의 두 정점 간의 단순 경로 상의 모든 정점의 가중치의 합을 반환하는 트리를 작성해보자. 트리는 각 정점들의 가중치의 변경까지도 지원해야 한다. Heavy-Light 분할의 구현은 다양하므로 본 구현에 국한될 필요는 없다.</p>

<h3 id="트리-분할-1">트리 분할</h3>

<p>트리의 분할에 앞서 우선 트리의 각 정점이 가져야 할 정보들은 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 트리의 정점
</span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 간선으로 연결된 정점
</span>        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># 정점 가중치
</span>        <span class="c1"># 첫 번째 DFS에서 초기화
</span>        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 서브 트리의 크기
</span>        <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># 정점의 부모
</span>        <span class="c1"># 두 번째 DFS에서 초기화
</span>        <span class="n">self</span><span class="p">.</span><span class="n">hld_root</span> <span class="o">=</span> <span class="n">self</span>  <span class="c1"># 구역의 대표 정점
</span>        <span class="n">self</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">:</span> <span class="n">SegmentTree</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># 구역을 관리하는 세그먼트 트리
</span>        <span class="n">self</span><span class="p">.</span><span class="n">hld_depth</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 구역의 깊이
</span>        <span class="n">self</span><span class="p">.</span><span class="n">hld_index</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 구역에서의 인덱스
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Node</code>의 구조는 분할의 각 구역마다 맨 앞 정점을 조장으로 두어 조장 정점에서 세그먼트 트리를 조작하고 나머지 정점들은 조장 정점을 참조하도록 의도한 것이다.</p>

<p>트리의 분할은 총 2번의 DFS로 이루어진다. 첫 번째 DFS에서는 각 정점의 서브 트리의 사이즈를 계산하고 무거운 간선을 색출해내는 작업을 하며 두 번째 DFS에서는 무거운 간선을 우선적으로 탐색하며 하나의 구역으로 묶어주는 작업을 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="c1"># 첫 번째 DFS, 정점의 서브 트리의 크기 계산 및 무거운 간선을 edge의 맨 앞으로 위치
</span>    <span class="k">def</span> <span class="nf">dfs1</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span>
                <span class="n">node</span><span class="p">.</span><span class="nf">dfs1</span><span class="p">()</span>
                <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">size</span>
                <span class="c1"># 서브 트리의 크기가 가장 큰 자식을 맨 앞으로 위치
</span>                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>첫 번째 DFS에서는 <code class="language-plaintext highlighter-rouge">Node</code>의 <code class="language-plaintext highlighter-rouge">size</code> 변수를 사용하여 정점의 서브 트리의 크기를 저장하고, 자식 정점들의 서브 트리의 크기를 조사하여 가장 큰 자식을 <code class="language-plaintext highlighter-rouge">edge</code> 배열의 맨 앞으로 위치시킨다. 이로서 <code class="language-plaintext highlighter-rouge">edge</code> 배열의 맨 앞에는 무거운 간선으로 연결된 자식 정점이 위치하게 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="c1"># 두 번째 DFS, 구역을 분할하고 세그먼트 트리 생성
</span>    <span class="k">def</span> <span class="nf">dfs2</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="c1"># 정점이 속한 구역의 정보를 넘겨줌
</span>            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_root</span> <span class="o">=</span> <span class="n">self</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_depth</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_index</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># 무거운 간선끼리 연결
</span>            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">dfs2</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="c1"># 가벼운 간선으로 연결된 자식으로 재귀
</span>            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">hld_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_depth</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">node</span><span class="p">.</span><span class="nf">dfs2</span><span class="p">([])</span>
        <span class="c1"># 무거운 간선으로 연결된 배열을 바탕으로 세그먼트 트리 구성
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_root</span> <span class="ow">is</span> <span class="n">self</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hld_segtree</span> <span class="o">=</span> <span class="nc">SegmentTree</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</code></pre></div></div>

<p>두 번째 DFS에서는 <code class="language-plaintext highlighter-rouge">edge</code> 배열의 맨 앞 자식 정점을 계속 방문하면서 <code class="language-plaintext highlighter-rouge">array</code>에 연결하고 이를 바탕으로 세그먼트 트리를 구성한다. 자식들을 계속 방문하면서 해당 정점이 속한 구역의 정보들을 넣어준다. 가벼운 간선들로 연결된 자식들은 빈 <code class="language-plaintext highlighter-rouge">array</code>를 줌으로서 새로 연결하도록 하고 있다.</p>

<h3 id="경로-쿼리">경로 쿼리</h3>

<p>두 정점을 피연산자로 한 경로 쿼리 함수는 두 정점이 속한 구역의 최소 공통 조상까지 한 구역씩 거슬러 올라가면서 해당 구역의 세그먼트 트리에 쿼리를 호출하도록 하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 두 정점의 단순 경로 상의 모든 정점의 가중치 합 반환
</span><span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># 한 구역씩 거슬러 올라가며 세그먼트 트리 참조
</span>    <span class="n">node</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">hld_depth</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hld_root</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_depth</span> <span class="o">==</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hld_depth</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">parent</span>
    <span class="c1"># 최소 공통 조상 구역에서의 구간 쿼리 처리
</span>    <span class="n">node</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">hld_index</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_index</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hld_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h3 id="전체-구현">전체 구현</h3>

<p>아래는 Heavy-Light 분할의 전체 구현이다. 위에서 정의한 <code class="language-plaintext highlighter-rouge">Node</code> 클래스를 외부 클래스로 한 번 더 감싼 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Heavy-Light 분할을 위한 세그먼트 트리, 구간 합과 인덱스 갱신 지원
</span><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>


<span class="c1"># Heavy-Light 분할을 지원하는 트리
</span><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="c1"># 트리의 정점
</span>    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span> <span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hld_root</span> <span class="o">=</span> <span class="n">self</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">:</span> <span class="n">SegmentTree</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hld_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hld_index</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">def</span> <span class="nf">dfs1</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span>
                    <span class="n">node</span><span class="p">.</span><span class="nf">dfs1</span><span class="p">()</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">size</span>
                    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">:</span>
                        <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">dfs2</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
            <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_root</span> <span class="o">=</span> <span class="n">self</span>
                <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_depth</span>
                <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_index</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">dfs2</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">hld_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_depth</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">node</span><span class="p">.</span><span class="nf">dfs2</span><span class="p">([])</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">hld_root</span> <span class="ow">is</span> <span class="n">self</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">hld_segtree</span> <span class="o">=</span> <span class="nc">SegmentTree</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    
    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">root</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="nf">dfs1</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="nf">dfs2</span><span class="p">([])</span>

    <span class="c1"># 정점 가중치 수정
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">hld_index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># 두 정점의 단순 경로 상의 모든 정점의 가중치 합 반환
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">]],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">hld_depth</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hld_root</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_depth</span> <span class="o">==</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hld_depth</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">parent</span>
        <span class="n">node</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">hld_index</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_root</span><span class="p">.</span><span class="n">hld_segtree</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hld_index</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">hld_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>P.S. 오일러 경로 테크닉을 사용하면 분할의 각 구역마다 하나의 세그먼트 트리를 두지 않고 전체 트리에 하나의 세그먼트 트리를 두어 해결할 수도 있다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="트리(trees)" /><category term="트리_분할(tree_decomposition)" /><category term="세그먼트_트리(segtree)" /><category term="최소_공통_조상(lca)" /><category term="Heavy-light_분할(hld)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">퍼시스턴트 세그먼트 트리</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst.html" rel="alternate" type="text/html" title="퍼시스턴트 세그먼트 트리" /><published>2024-01-30T00:00:00+00:00</published><updated>2024-01-30T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst.html"><![CDATA[<h2 id="소개">소개</h2>

<p>퍼시스턴트 세그먼트 트리란 매 수정 쿼리마다 트리의 상태를 덮어쓰지 않고 모두 저장하고 있는 세그먼트 트리를 말한다. 이러한 특성 때문에 퍼시스턴트 세그먼트 트리는 주로 2차원 상에서의 세그먼트 트리를 구현하기 위해서 많이 쓰인다.</p>

<h2 id="원리">원리</h2>

<p>아래와 같이 크기가 8인 배열을 관리하는 세그먼트 트리에서 3번 인덱스의 값을 바꾸는 연산을 수행할 것이다. 기존의 세그먼트 트리는 3번 인덱스를 가리키는 리프 정점의 모든 조상 정점의 값을 갱신해주었다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7):::red
    B1(0 ~ 3):::red
    B2(4 ~ 7)
    C1(0 ~ 1)
    C2(2 ~ 3):::red
    C3(4 ~ 5)
    C4(6 ~ 7)
    D1(0)
    D2(1)
    D3(2)
    D4(3):::red
    D5(4)
    D6(5)
    D7(6)
    D8(7)

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>하지만 퍼시스턴트 세그먼트 트리는 정점의 값을 수정하지 않는다. 퍼시스턴트 세그먼트 트리에서는 새로운 값을 지닌 정점을 새로 만들어 연결해준다. 우선 새로운 루트 정점을 생성하고 3번 인덱스를 가리키는 리프 정점까지 새로운 값으로 만들어준다. 그 후 만들어준 정점들과 기존에 있던 정점들을 대응되는 자리에 연결해준다.</p>

<div style="column-count: 2">
    <pre class="mermaid">
        graph TD

        A --&gt; B1
        B1 --&gt; C2
        C2 --&gt; D4

        A(0 ~ 7):::green
        B1(0 ~ 3):::green
        C2(2 ~ 3):::green
        D4(3):::green

        classDef green stroke:#0F0, fill:#EFE
    </pre>
    <pre class="mermaid">
        graph TD

        A --&gt; B1
        A --&gt; B2
        B1 --&gt; C1
        B1 --&gt; C2
        C2 --&gt; D3
        C2 --&gt; D4

        A(0 ~ 7):::green
        B1(0 ~ 3):::green
        B2(4 ~ 7)
        C1(0 ~ 1)
        C2(2 ~ 3):::green
        D3(2)
        D4(3):::green

        classDef green stroke:#0F0, fill:#EFE
    </pre>
</div>

<p>이 결과 세그먼트 트리의 루트 정점이 두 개가 된다. 하나는 인덱스 수정 쿼리가 처리되기 전의 루트이며, 다른 하나는 쿼리 처리 후의 루트이다. 각각의 루트 정점을 통해서 우리는 세그먼트 트리의 쿼리 처리 전의 상태와 처리 후의 상태를 모두 들여다볼 수 있게 되었다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8
    A_mod --&gt; B1_mod
    A_mod --&gt; B2
    B1_mod --&gt; C1
    B1_mod --&gt; C2_mod
    C2_mod --&gt; D3
    C2_mod --&gt; D4_mod

    A(0 ~ 7)
    B1(0 ~ 3)
    B2(4 ~ 7)
    C1(0 ~ 1)
    C2(2 ~ 3)
    C3(4 ~ 5)
    C4(6 ~ 7)
    D1(0)
    D2(1)
    D3(2)
    D4(3)
    D5(4)
    D6(5)
    D7(6)
    D8(7)
    A_mod(0 ~ 7):::green
    B1_mod(0 ~ 3):::green
    C2_mod(2 ~ 3):::green
    D4_mod(3):::green
    A:::root
    A_mod:::root

    subgraph 수정 전
        A
        B1
        B2
        C1
        C2
        C3
        C4
        D1
        D2
        D3
        D4
        D5
        D6
        D7
        D8
    end

    subgraph 수정 후
        A_mod
        B1_mod
        C2_mod
        D4_mod
    end

    classDef green stroke:#0F0, fill:#EFE
    classDef root stroke:#F00, stroke-width:3px
</pre>

<h2 id="구현">구현</h2>

<p>어떠한 시점에서의 구간 합을 구해주는 퍼시스턴트 세그먼트 트리를 구현해보자. 퍼시스턴트 세그먼트 트리의 구현은 기존의 세그먼트 트리에서 인덱스 수정 함수의 메커니즘을 바꾼 것이다. 퍼시스턴트 세그먼트 트리에서는 루트 정점이 여러개가 발생하기 때문에 이를 관리해주는 배열을 선언할 필요가 있다. 우선 기존 세그먼트 트리의 정점 클래스에서 생성자 및 구간 합 함수는 그대로 가져온다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>그 후 인덱스 수정 함수에는 정점 자신의 값을 수정하는 대신에, 새로 만든 정점에 자식들을 연결시키고 값을 수정해준 뒤 완성된 정점을 반환하는 방식으로 바꿔주면 된다. 이 함수를 호출하면 인덱스 수정 쿼리가 처리된 후의 상태를 가진 루트 정점이 반환이 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">:</span>
        <span class="c1"># 새로운 정점 생성
</span>        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">([</span><span class="n">value</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="c1"># 재귀 및 기존 정점와 연결
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="c1"># 자신의 값을 수정하는 대신 새로 만든 정점의 값을 수정해줌
</span>            <span class="n">new_node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">new_node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">new_node</span>
</code></pre></div></div>

<p>아래는 위에서 완성한 세그먼트 트리의 정점 클래스를 외부 클래스로 한 번 더 감싸 구현을 완료한 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>

        <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">SegmentTree.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">([</span><span class="n">value</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">new_node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">return</span> <span class="n">new_node</span>

    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">))]</span>

    <span class="c1"># 구간 쿼리, 시점 t를 같이 입력받음
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># 원소 갱신
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>

</code></pre></div></div>

<p>위 클래스 인스턴스에서 구간 합을 구하는 함수 <code class="language-plaintext highlighter-rouge">get_sum</code>에 시점 <code class="language-plaintext highlighter-rouge">t</code>를 같이 입력하여 해당 시점에서의 구간 합을 구할 수 있다.</p>

<h2 id="응용">응용</h2>

<p>퍼시스턴트 세그먼트 트리를 사용하면 다음 문제를 풀 수 있다.</p>

<blockquote>
  <p>$xy$ 평면에 여러 점들이 있다. 점들의 좌표는 모두 정수이다. 이에 다음 명령을 처리하는 프로그램을 작성하시오.</p>

  <p><code class="language-plaintext highlighter-rouge">x1 y1 x2 y2</code>: $\lbrace \left(x, y\right) |$<code class="language-plaintext highlighter-rouge">x1</code>$\le x &lt;$<code class="language-plaintext highlighter-rouge">x2</code>$\land$<code class="language-plaintext highlighter-rouge">y1</code>$\le y &lt;$<code class="language-plaintext highlighter-rouge">y2</code>$\rbrace$ 영역에 속하는 점의 개수를 출력한다.</p>
</blockquote>

<pre class="mermaid" style="background-color: white">
    quadrantChart
        title xy
        x-axis x
        y-axis y
        4,3: [0.4, 0.3]
        3,8: [0.3, 0.8]
        2,6: [0.2, 0.6]
        8,7: [0.8, 0.7]
        6,5: [0.6, 0.5]
        7,1: [0.7, 0.1]
        5,6: [0.5, 0.6]
</pre>

<p>주어진 평면의 $x$축을 시간축으로 보자. $y$축 크기만큼의 배열을 퍼시스턴트 세그먼트 트리로 관리하며 처음($t=0$)에는 배열의 값을 전부 0으로 초기화한다. 점들을 시간($x$ 좌표값)순으로 나열하고 이 순서대로 점들의 $y$ 좌표에 해당하는 인덱스에 더하기 1을 해준다. 위의 예시의 경우 7개의 점에 대해 각각 $t$번째 점마다 트리에 다음과 같은 상태들이 저장될 것이다.</p>

<p><img class="post-image" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/posts/pst-1.png" style="background-color: white" /></p>

<table>
  <thead>
    <tr>
      <th>$y$</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$t=0$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=1$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=2$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=3$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=4$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td>2</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=5$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td>2</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=6$</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td>2</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=7$</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>이렇게 관리를 하게 되면 시점 $t$에서의 $\left[l, r\right)$ 범위의 구간 합은 $x$ 좌표값 순으로 $t$번째의 점과 그 왼쪽에 있는 점들 중에서 $y$ 좌표가 $\left[l, r\right)$ 범위 안에 있는 모든 점들의 개수가 된다. 예시로, $t=6$에서의 $\left[4, 8\right)$ 범위의 구간 합은 다음 그림의 빨간 영역에 걸쳐있는 점의 개수이다.</p>

<p><img class="post-image" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/posts/pst-2.png" style="background-color: white" /></p>

<p>이제 이 퍼시스턴트 세그먼트 트리를 바탕으로 쿼리를 처리해보자. <code class="language-plaintext highlighter-rouge">3 4 7 8</code>의 답은 무엇일까? $x$ 좌표가 $\left[3, 7\right)$ 범위에 속해있는 점들 중 $x$ 좌표값 순으로 가장 뒤에 있는 점은 $(6, 5)$(5번째 점)이다. 그리고 $x$ 좌표가 $\left[3, 7\right)$ 범위의 왼쪽, 즉 3보다 작은 점들 중 $x$ 좌표값 순으로 가장 뒤에 있는 점은 $(2, 6)$(1번째 점)이다. 따라서 정답은 시점 $t=5$에서의 $\left[4, 8\right)$ 구간 합에서 시점 $t=1$에서의 $\left[4, 8\right)$ 구간 합을 뺌으로서 구할 수 있다.</p>

<p><img class="post-image" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/posts/pst-3.png" style="background-color: white" /></p>

<p>퍼시스턴트 세그먼트 트리를 이용하면 위 문제의 명령을 $O(\log N)$의 시간복잡도로 해결할 수 있다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="자료_구조(data_structures)" /><category term="트리(trees)" /><category term="세그먼트_트리(segtree)" /><category term="퍼시스턴트_세그먼트_트리(pst)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">느리게 갱신되는 세그먼트 트리</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/29/lazyprop.html" rel="alternate" type="text/html" title="느리게 갱신되는 세그먼트 트리" /><published>2024-01-29T00:00:00+00:00</published><updated>2024-01-29T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/29/lazyprop</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/29/lazyprop.html"><![CDATA[<h2 id="소개">소개</h2>

<h3 id="문제-제시">문제 제시</h3>

<p>기존의 세그먼트 트리는 한 번에 하나의 값만을 수정할 수 있었다. 하지만 어떠한 경우에는 구간 전체의 값에 수정 명령을 내리고 싶을 수도 있다. 이를테면 특정 구간에 모두 일정한 값을 더하거나 곱하도록 할 수 있다. 이를 수행하기 위해서 기존의 세그먼트 트리의 인덱스 수정 연산을 통해서 인덱스 하나하나의 값을 수정하는 방법을 취할 경우 매 구간 수정 쿼리마다 $O(N\log N)$의 시간복잡도를 가지게 되며 이는 좋은 방법이 아니다.</p>

<h3 id="지연-갱신">지연 갱신</h3>

<p>이를 해결하는 한 방법으로 세그먼트 트리에 지연 갱신을 적용하는 것이다. 지연 갱신이란 갱신 명령이 들어왔을 때 실제 갱신을 실행하지 않고 명령에 대한 정보만을 저장하고 있다가 나중에 필요할 때 계산해내는 방식이다.</p>

<h2 id="원리">원리</h2>

<p>우선 기존의 세그먼트 트리의 특정 한 인덱스의 값을 수정하는 연산을 떠올려보자. 특정 인덱스의 값을 수정하면 해당 인덱스를 가리키는 세그먼트 트리의 리프 정점의 모든 조상 정점을 같이 수정해주어야 했다. 지연 갱신을 적용한 세그먼트 트리 역시 주어진 구간을 나타내는 모든 정점의 조상 정점들을 같이 수정하면 과정을 거친다. 이를 구현하기 위해서 각 정점들은 자신들이 나타내는 구간의 “갱신 정보”를 저장하는 변수를 가지고 있다.</p>

<p>예시를 보자. 우리는 아래 세그먼트 트리로 관리하고 있는 배열에서 1 ~ 7 범위의 값에 어떠한 값 $c$를 더하려고 한다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7):::green
    B1(0 ~ 3):::green
    B2(4 ~ 7):::red
    C1(0 ~ 1):::green
    C2(2 ~ 3):::red
    C3(4 ~ 5)
    C4(6 ~ 7)
    D1(0)
    D2(1):::red
    D3(2)
    D4(3)
    D5(4)
    D6(5)
    D7(6)
    D8(7)

    classDef red stroke:#F00, fill:#FEE
    classDef green stroke:#0F0, fill:#EFE
</pre>

<p>위 그림에서 빨간색 정점는 1 ~ 7 범위를 표현하는 정점들이다. 그리고 초록색 정점들은 루트에서부터 DFS를 통해 빨간색 정점들에 도달하기 위해서 건너왔던 정점들이며 빨간색 정점들의 모든 조상 정점이기도 하다. 우선 초록색 정점와 빨간색 정점들에 대해서는 곧바로 수정을 진행해준다. 그 후 빨간색 정점들의 자식 정점들에게는 갱신 정보인 $c$값을 저장해준다. 아래 그림에서 노란색으로 표현된 정점들은 $c$에 대한 쿼리가 적용된 정점들이고 자주색으로 표현된 정점들은 아직 값이 적용되지 않았지만 $c$에 대한 갱신 정보를 담고 있는 정점들이다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7):::yellow
    B1(0 ~ 3):::yellow
    B2(4 ~ 7):::yellow
    C1(0 ~ 1):::yellow
    C2(2 ~ 3):::yellow
    C3(4 ~ 5):::magenta
    C4(6 ~ 7):::magenta
    D1(0)
    D2(1):::yellow
    D3(2):::magenta
    D4(3):::magenta
    D5(4)
    D6(5)
    D7(6)
    D8(7)

    classDef yellow stroke:#FF0, fill:#FFE
    classDef magenta stroke:#F0F, fill:#FEF
</pre>

<p>여기까지가 구간 모든 원소에 $c$를 더하는 쿼리의 동작이다. 이 쿼리로 수정해야 하는 정점 개수의 최댓값은 $O(\log N)$ 꼴이 될 것이므로 이 쿼리의 시간복잡도 또한 $O(\log N)$이다.</p>

<p>여기서 구간 2 ~ 4의 합을 구한다고 해보자. 구간 합 연산 역시 기존의 세그먼트 트리처럼 DFS를 통해 연산의 대상이 되는 범위를 지닌 정점을 찾아가면 된다. 여기서 다른 점은 DFS로 지나오는 모든 정점들에 대해서 갱신 정보를 바탕으로 값을 수정해준 뒤 그 정보를 계속해서 자식 정점쪽으로 전파해주면서 진행해줘야 한다는 것이다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7):::yellow
    B1(0 ~ 3):::yellow
    B2(4 ~ 7):::yellow
    C1(0 ~ 1):::yellow
    C2(2 ~ 3):::yellow
    C3(4 ~ 5):::yellow
    C4(6 ~ 7):::magenta
    D1(0)
    D2(1):::yellow
    D3(2):::magenta
    D4(3):::magenta
    D5(4):::yellow
    D6(5):::magenta
    D7(6)
    D8(7)

    C2:::note
    D5:::note

    subgraph 전파
        C3
        D5
        D6
    end

    classDef yellow stroke:#FF0, fill:#FFE
    classDef magenta stroke:#F0F, fill:#FEF
    classDef note stroke:#F00, stroke-width:3px, stroke-dasharray: 5 3
</pre>

<p>위 그림에서 빨간색 테두리에 속한 정점들이 2 ~ 4의 구간을 표현하고 있는 정점이다. 빨간색 테두리로 가리키고 있는 인덱스 4의 리프 정점에 접근하는 과정에서, 4 ~ 5 구간을 가리키는 정점을 지나오면서 해당 정점이 가지고 있던 갱신 정보를 자식 정점로 전파하며 갱신을 반영한 것을 볼 수 있다. 이렇듯 모든 정점에 갱신 정보들을 누적해두고 나중에 그 값을 구할 때 누적되어있던 정보들을 적용해주면서 내려오는 것이다.</p>

<h2 id="구현">구현</h2>

<p>앞서 설명한 지연 갱신 방식을 사용해 구간 합을 구하는 쿼리와 구간에 일정한 수를 더하는 쿼리를 처리하는 세그먼트 트리를 구현해 볼 것이다. 기존의 세그먼트 트리에서 달라진 구현은 각 정점들에 갱신 정보를 저장하는 변수를 새로 만든 후 구간 합을 구하는 쿼리를 처리할 때 갱신 정보를 자식 정점로 전파하는 루틴을 추가해야 한다는 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 갱신 정보를 저장하는 변수
</span>        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="구간-쿼리">구간 쿼리</h3>

<p>구간 합을 구하는 연산은 기존의 세그먼트 트리와 동일하되 자식 정점로 갱신 정보를 전파하는 코드만 추가하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 갱신 정보의 전파
</span>        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">prop</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">prop</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 기존 세그먼트 트리의 구간 쿼리
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<h3 id="구간-갱신">구간 갱신</h3>

<p>구간 갱신 쿼리를 처리하는 함수는 구간 합을 처리하는 함수처럼 DFS 재귀 함수로 구성하며, 각각의 정점을 방문하면서 구간 갱신 연산의 대상이 되는 구간 $\left[i, j\right)$과 현재 정점이 나타내는 구간 $\left[l, r\right)$에 대해서 다음 3가지 경우마다 처리를 달리해주면 된다.</p>

<ol>
  <li>$\left[l, r\right)$ 구간이 $\left[i, j\right)$ 구간 안에 포함되는 경우</li>
  <li>$\left[l, r\right)$ 구간이 $\left[i, j\right)$ 구간에 포함되진 않지만 걸쳐있는 경우</li>
  <li>$\left[l, r\right)$ 구간과 $\left[i, j\right)$ 구간이 겹치지 않는 경우</li>
</ol>

<p>1의 경우 자식 정점들에 갱신 정보를 저장하고 현재 정점의 값을 갱신해주면 되며, 2의 경우는 자식 정점들로 재귀한 뒤 현재 정점의 값을 수정해주면 된다. 3의 경우에는 아무 행동도 취하지 않으면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="c1"># 갱신 정보 저장
</span>            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">amount</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">amount</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">amount</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
</code></pre></div></div>

<h3 id="전체-구현">전체 구현</h3>

<p>아래는 전체 구현이다. 위에서 완성한 <code class="language-plaintext highlighter-rouge">Node</code> 클래스를 외부 클래스로 한 번 더 감싼 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 구간 합 구하기, 구간에 일정한 수 더하기 지원
</span><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">prop</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">prop</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">amount</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">prop</span> <span class="o">+=</span> <span class="n">amount</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">amount</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>

    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="c1"># 구간 쿼리
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># 구간 갱신
</span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="자료_구조(data_structures)" /><category term="트리(trees)" /><category term="세그먼트_트리(segtree)" /><category term="느리게_갱신되는_세그먼트_트리(lazyprop)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">최소 공통 조상</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/20/lca.html" rel="alternate" type="text/html" title="최소 공통 조상" /><published>2024-01-20T00:00:00+00:00</published><updated>2024-01-20T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/20/lca</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/20/lca.html"><![CDATA[<h2 id="소개">소개</h2>

<p>최소 공통 조상 문제는 트리의 임의의 두 정점의 조상 정점이면서 두 정점로부터의 거리가 가장 가까운 정점을 찾는 문제이다. 최소 공통 조상 문제는 트리 상의 임의의 두 정점의 경로를 탐색하는 데에 쓰일 수 있다.</p>

<h2 id="해결">해결</h2>

<p>최소 공통 조상을 찾기 위해서 우리는 단순히 두 정점에서부터 출발해 만날때까지 하나씩 올라오는 방법을 생각해 볼 수 있다. 하지만 이 방법은 크기가 $N$인 트리에서 $O(N)$의 시간복잡도를 가질 수 있어 적절하지 않다. 우리는 이 문제를 더 빠른 방법으로 해결해 볼 것이며 대표적으로 아래 두 방법이 존재한다.</p>

<h3 id="다이나믹-프로그래밍">다이나믹 프로그래밍</h3>

<p>이 방식의 메인 아이디어는 조상 정점들을 탐색할 때 이분 탐색하듯이 거슬러 올라가도록 만드는 것이다. 우선 트리를 전처리한다. 트리 전체를 순회하면서 각 정점마다 깊이 정보와 함께 $2^n \left(n = 0, 1, 2 …\right)$번째 조상 정점들을 저장해둘 것이다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B1 --&gt; C3
    C1 --&gt; D1
    C1 --&gt; D2
    D2 --&gt; E1
    D2 --&gt; E2
    E1 --&gt; F1

    A(( ))
    B1(( )):::green
    B2(( ))
    C1(( ))
    C2(( ))
    C3(( ))
    D1(( ))
    D2(( )):::green
    E1(( )):::green
    E2(( ))
    F1(( )):::red

    classDef red stroke:#F00, fill:#FEE
    classDef green stroke:#0F0, fill:#EFE
</pre>

<p>위 트리를 예시로 들어보자. 트리의 맨 아래 정점는 깊이가 5이고(루트의 깊이는 0이다) $2^0$, $2^1$, $2^2$번째 조상이 존재하므로 정점에 이 정보를 저장해 둔다. 모든 정점이 이러한 정보를 저장하고 있다면 최소 공통 조상 문제를 빠르게 풀 수 있다.</p>

<p>크기가 $N$인 트리의 임의의 정점 $\text A$와 $\text B$의 최소 공통 조상 $\text C$를 찾아가는 상황을 생각해보자. 트리는 위 예시처럼 전처리가 되어 있으며, 정점 $\text A$의 깊이가 더 크고 정점 $\text A$와 $\text C$ 경로 사이에 정점 $\text B$와 깊이가 같은 정점 $\text A’$이 있다고 하자. 도식화하면 아래 그림과 같으며 다른 정점는 생략하였다.</p>

<pre class="mermaid">
    graph RL

    root --&gt; C
    C --&gt; Ap
    Ap -- <span class="mathjax mj1"></span> --&gt; A
    C --&gt; B

    root((Root))
    A(("<span style="display: inline-block; width: 1em">A</span>"))
    Ap(("<span style="display: inline-block; width: 1em">A'</span>"))
    B(("<span style="display: inline-block; width: 1em">B</span>"))
    C(("<span style="display: inline-block; width: 1em">C</span>"))
</pre>
<ol class="mathjax">
    <li class="mj1">$d$</li>
</ol>

<p>우선 정점 $\text A$에서부터 정점 $\text B$와 깊이가 같은 정점인 $\text A’$까지 거슬러 올라온다. 그러기 위해서 거슬러 올라가야 하는 거리인 $d$를 구한다. 이는 간단히 정점 $\text A$의 깊이에서 정점 $\text B$의 깊이를 뺀 값이다. 예시로 $d = 13$이라고 해보자. 이는 다음과 같이 표현할 수 있다.</p>

<p>$$
d = 13 = 1101_{2} = 2^3 + 2^2 + 2^0
$$</p>

<p>우리는 앞서 모든 정점의 $2^n$번째 조상 정점을 구해놓았으므로 다음과 같은 경로로 정점 $\text A$에서 정점 $\text A’$로 갈 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -. <span class="mathjax mj1"></span> .-&gt; node1
    node1 -. <span class="mathjax mj2"></span> .-&gt; node2
    node2 -. <span class="mathjax mj3"></span> .-&gt; Ap

    A(("<span style="display: inline-block; width: 1em">A</span>"))
    Ap(("<span style="display: inline-block; width: 1em">A'</span>"))
    node1(( ))
    node2(( ))
</pre>
<ol class="mathjax">
    <li class="mj1">$2^3$</li>
    <li class="mj2">$2^2$</li>
    <li class="mj3">$2^0$</li>
</ol>

<p>즉, 정점 $\text A$에서 정점 $\text A’$로 가는 데 $O(\log N)$의 시간이 든다. 이제 정점 $\text A’$과 $\text B$에서 동시에 $\text C$를 향해 올라온다. 거슬러 올라갈 조상 정점을 선택할 떄는 $\text C$를 넘어서서 거슬러 올라가지 않으면서 가장 멀리 갈 수 있는 정점을 선택하면 된다. 이를 수학적으로 표현하면, 다음 집합의 최댓값 $m$에 대해 $2^m$번째 조상으로 계속해서 거슬러 올라가는 과정을 반복하면 된다.</p>

<p>$$
\lbrace 0 \rbrace \cap \lbrace k | \text 2^k\text{번째 조상이 같지 않음}\rbrace
$$</p>

<pre class="mermaid">
    graph TD

    subgraph O
        direction LR
        Ap1 -. <span class="mathjax mj1"></span> .-&gt; node1
        B1 -. <span class="mathjax mj2"></span> .-&gt; node2
        node1 -.-&gt; C1
        node2 -.-&gt; C1
        C1 -.-&gt; root1
    end

    subgraph X
        direction LR
        Ap2 -.-&gt; C2
        B2 -.-&gt; C2
        Ap2 -. <span class="mathjax mj3"></span> .-&gt; node3
        C2 -.-&gt; node3
        B2 -. <span class="mathjax mj4"></span> .-&gt; node3
        node3 -.-&gt; root2
    end

    Ap1(("<span style="display: inline-block; width: 1em">A'</span>"))
    Ap2(("<span style="display: inline-block; width: 1em">A'</span>"))
    B1(("<span style="display: inline-block; width: 1em">B</span>"))
    B2(("<span style="display: inline-block; width: 1em">B</span>"))
    C1(("<span style="display: inline-block; width: 1em">C</span>"))
    C2(("<span style="display: inline-block; width: 1em">C</span>"))
    root1((Root))
    root2((Root))
    node1(( ))
    node2(( ))
    node3(( ))
</pre>
<ol class="mathjax">
    <li class="mj1">$2^k$</li>
    <li class="mj2">$2^k$</li>
    <li class="mj3">$2^{k+1}$</li>
    <li class="mj4">$2^{k+1}$</li>
</ol>

<p>위 과정을 반복하면 최소 공통 조상인 정점 $\text C$에서 만나게 될 것이다. 이 과정 역시 $O(\log N)$의 시간이 든다. 따라서 다이나믹 프로그래밍 기법을 사용한 최소 공통 조상 문제 풀이의 시간복잡도는 $O(\log N)$이다.</p>

<h4 id="구현">구현</h4>

<p>아래는 최소 공통 조상의 다이나믹 프로그래밍적 접근을 코드화한 것이다. 각 정점마다 $2^n$번째 조상을 저장하는 배열 <code class="language-plaintext highlighter-rouge">root</code>를 만들고 전처리 함수 <code class="language-plaintext highlighter-rouge">preprocess</code>를 통해 이를 채워둔다. 그리고 <code class="language-plaintext highlighter-rouge">lca</code>함수를 이용해 최소 공통 조상을 구한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">math</span> <span class="kn">import</span> <span class="n">log2</span>


<span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 간선으로 연결된 다른 정점들
</span>            <span class="c1"># 2^n번째 조상을 저장하는 리스트
</span>            <span class="c1"># 인덱스 i는 2^i번째 조상임을 의미
</span>            <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 정점의 깊이
</span>
        <span class="c1"># 전처리, 2^i번째 조상을 전부 구함
</span>        <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">parent</span>
                <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">root</span><span class="p">):</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="nf">preprocess</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tree</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
            <span class="n">a</span><span class="p">.</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">b</span><span class="p">.</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="c1"># 전처리
</span>        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="nf">preprocess</span><span class="p">()</span>

    <span class="c1"># 최소 공통 조상 구하기
</span>    <span class="k">def</span> <span class="nf">lca</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="n">close</span><span class="p">,</span> <span class="n">far</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">]],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">depth</span><span class="p">)</span>
        <span class="c1"># 더 깊이 있는 정점을 같은 깊이까지 끌어올린다
</span>        <span class="n">d</span> <span class="o">=</span> <span class="n">far</span><span class="p">.</span><span class="n">depth</span> <span class="o">-</span> <span class="n">close</span><span class="p">.</span><span class="n">depth</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="n">d</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">far</span> <span class="o">=</span> <span class="n">far</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># 두 정점로부터 최소 공통 조상까지 거슬러 올라온다
</span>        <span class="k">while</span> <span class="n">close</span> <span class="o">!=</span> <span class="n">far</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">far</span><span class="p">.</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">far</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="n">close</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">]:</span>
                <span class="n">t</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">close</span><span class="p">,</span> <span class="n">far</span> <span class="o">=</span> <span class="n">close</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">far</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">far</span>
</code></pre></div></div>

<h3 id="오일러-경로-테크닉">오일러 경로 테크닉</h3>

<p><a href="../../../2024/01/18/euler_tour_technique.html">오일러 경로 테크닉</a>이란 트리의 DFS 방문 순서대로 정점들을 나열하여 트리를 선형적으로 관리하는 기법이다. 오일러 경로 테크닉을 이용한 최소 공통 조상 문제의 풀이는 어떠한 정점 $\text A$와 $\text B$ 사이의 최소 공통 조상은 DFS 방문 순서상 정점 $\text A$와 $\text B$ 사이에서 반드시 재방문하게 됨을 이용한다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Stirling_permutation_Euler_tour.svg/306px-Stirling_permutation_Euler_tour.svg.png" style="background-color: white" /></p>

<p>최소 공통 조상 문제를 풀기 위해서는 정점에 번호를 매기는 방법을 조금 다르게 한다. 우선 빈 배열을 하나 생성한 뒤 DFS를 수행하면서 재방문을 포함해 정점에 방문할 때마다 해당 정점을 배열의 끝에 추가한다. 그리고 각 정점에는 깊이와 함께 배열에서 첫 번째와 마지막으로 등장하는 인덱스 번호를 저장한다. 아래 예시를 보자.</p>

<pre class="mermaid">
    graph TD
    A --&gt; B
    A --&gt; C
    A --&gt; D
    B --&gt; E
    B --&gt; F
    E --&gt; G

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
    G((G))
</pre>

<p>$$
\text{Array: }\left[\text{A,  B,  E,  G,  E,  B,  F,  B,  A,  C,  A,  D,  A}\right]
$$</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
      <th>$\text E$</th>
      <th>$\text F$</th>
      <th>$\text G$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Depth</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <td>index<sub>start</sub></td>
      <td>0</td>
      <td>1</td>
      <td>9</td>
      <td>11</td>
      <td>2</td>
      <td>6</td>
      <td>3</td>
    </tr>
    <tr>
      <td>index<sub>end</sub></td>
      <td>12</td>
      <td>7</td>
      <td>9</td>
      <td>11</td>
      <td>4</td>
      <td>6</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>이 상황에서 정점 $\text F$와 $\text G$의 최소 공통 조상을 찾아보자. 배열 상에서 정점 $\text F$나 $\text G$가 처음 등장하는 인덱스는 3, 가장 마지막으로 등장하는 인덱스는 6이다. 따라서 인덱스 3과 6 사이에 있는 정점들 중에서 깊이가 가장 작은 정점인 $\text B$가 이 두 정점의 최소 공통 조상이다.</p>

<p>$$
\text{A,  B,  E, }\left[\text{G,  E,  B,  F}\right]\text{,  B,  A,  C,  A,  D,  A}
$$</p>

<pre class="mermaid">
    graph TD
    A --&gt; B
    A --&gt; C
    A --&gt; D
    B --&gt; E
    B --&gt; F
    E --&gt; G

    A((A))
    B((B)):::red
    C((C))
    D((D))
    E((E)):::red
    F((F)):::red
    G((G)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>이는 구간 최솟값 쿼리로 이해할 수 있으므로 세그먼트 트리를 사용하여 $O(\log N)$의 시간만에 문제를 해결할 수 있다.</p>

<h4 id="구현-1">구현</h4>

<p>위 방법을 사용해 최소 공통 조상 문제를 푸는 알고리즘의 구현은 아래 코드 이외에도 다양하다. 아래 코드는 트리 클래스를 만들어 객체지향적인 구현을 한 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 구간 최솟값 쿼리를 지원하는 세그먼트 트리 (구현 편의를 위해 원소 갱신은 미지원)
</span><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">any</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_min</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">any</span> <span class="ow">or</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">lv</span><span class="p">,</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">rv</span>
                <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">lv</span>
                <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">any</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="c1"># 구간 최솟값 쿼리
</span>    <span class="k">def</span> <span class="nf">get_min</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">any</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">get_min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>


<span class="c1"># 최소 공통 조상 쿼리를 지원하는 트리
</span><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
    <span class="c1"># 트리의 정점
</span>    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 간선으로 연결된 다른 정점들
</span>            <span class="n">self</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 정점의 깊이
</span>            <span class="n">self</span><span class="p">.</span><span class="n">in_num</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># 정점 간의 대소 비교 정의, 이는 세그먼트 트리의 원소로서 사용하기 위함임
</span>        <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">depth</span>

        <span class="c1"># 오일러 경로 테크닉으로 생성되는 리스트 반환
</span>        <span class="k">def</span> <span class="nf">euler_tour</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">parent</span><span class="p">:</span> <span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Tree.Node</span><span class="sh">'</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">self</span><span class="p">.</span><span class="n">in_num</span> <span class="o">=</span> <span class="n">num</span>
            <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="nf">euler_tour</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_num</span><span class="p">)</span>  <span class="c1"># 재귀
</span>                    <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">array</span>
    
    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">segtree</span><span class="p">:</span> <span class="n">SegmentTree</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="nb">int</span> <span class="n">edge</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
        <span class="c1"># 전처리
</span>        <span class="n">self</span><span class="p">.</span><span class="n">segtree</span> <span class="o">=</span> <span class="nc">SegmentTree</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="nf">euler_tour</span><span class="p">())</span>

    <span class="c1"># 최소 공통 조상
</span>    <span class="k">def</span> <span class="nf">lca</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">segtree</span><span class="p">.</span><span class="nf">get_min</span><span class="p">(</span>
            <span class="nf">min</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">in_num</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">in_num</span><span class="p">),</span>
            <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">out_num</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">out_num</span><span class="p">)</span>
        <span class="p">).</span><span class="n">index</span>
</code></pre></div></div>

<p>위 코드에서 <code class="language-plaintext highlighter-rouge">Tree</code> 클래스는 최소 공통 조상을 구할 트리를 나타낸다. <code class="language-plaintext highlighter-rouge">preprocess</code> 함수를 통해 오일러 경로 테크닉을 사용하여 배열을 만들고 세그먼트 트리를 구성한다. 그 후에 세그먼트 트리를 가지고 <code class="language-plaintext highlighter-rouge">lca</code> 함수로 들어오는 최소 공통 조상 쿼리를 처리한다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="트리(trees)" /><category term="오일러_경로_테크닉(euler_tour_technique)" /><category term="최소_공통_조상(lca)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">오일러 경로 테크닉</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique.html" rel="alternate" type="text/html" title="오일러 경로 테크닉" /><published>2024-01-18T00:00:00+00:00</published><updated>2024-01-18T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique.html"><![CDATA[<h2 id="소개">소개</h2>

<p>트리는 비선형 자료구조다. 비선형이라고 함은 적어도 2차원 상에서 생각해야 한다는 것이다. 오일러 경로 테크닉은 비선형 자료구조인 트리를 다루기 쉬운 선형 자료구조로 환원하는 방법을 제시한다. 오일러 경로 테크닉이라고 해서 오일러 경로에 대한 정의나 오일러 경로를 구하는 알고리즘을 알 필요는 없다.</p>

<h2 id="원리">원리</h2>

<p>오일러 경로 테크닉은 쉽게 말해서 DFS로 정점에 순서를 부여하고 그 순서대로 나열하는 것이다. 아래 트리를 오일러 경로 테크닉을 통해 정점에 순서를 부여해보자.</p>

<div style="column-count: 2">
    <pre class="mermaid">
        graph TD
        A --&gt; B
        A --&gt; C
        A --&gt; D
        B --&gt; E
        B --&gt; F
        E --&gt; G

        A((A))
        B((B))
        C((C))
        D((D))
        E((E))
        F((F))
        G((G))
    </pre>

    <img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Stirling_permutation_Euler_tour.svg/306px-Stirling_permutation_Euler_tour.svg.png" style="background-color: white" />
</div>

<p>위 트리를 옆의 그림과 같이 DFS 방식으로 순회하면서 각 정점에 총 두 개의 번호 $\text{in}$, $\text{out}$을 부여한다. $\text{in}$은 DFS를 하면서 정점에 방문한 순서이고, $\text{out}$은 해당 정점을 탈출하는 시점에서 다음으로 방문할 정점에 부여할 $\text{in}$ 번호이다. 번호를 전부 매기면 다음과 같이 될 것이다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
      <th>$\text E$</th>
      <th>$\text F$</th>
      <th>$\text G$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\text{in}$</td>
      <td>0</td>
      <td>1</td>
      <td>5</td>
      <td>6</td>
      <td>2</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$\text{out}$</td>
      <td>7</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>4</td>
      <td>5</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<p>정점들을 $\text{in}$ 번호 순서대로 나열하고 배열을 만들어보자. 각 정점의 $\text{in}$ 번호가 이 배열에서의 인덱스와 일치한다.</p>

<p>$$
\left[\text{A, B, E ,G, F, C, D}\right]
$$</p>

<p>$\text{in}$ 번호와 $\text{out}$ 번호는 무엇을 의미할까? 신기하게도 어떠한 정점 $\text X$를 루트로 하는 서브 트리의 모든 정점는 $\text X$의 $\text{in}$ 번호와 $\text{out}$ 번호의 사이에 있다. 즉 $\text{in}$ 번호와 $\text{out}$ 번호는 서브 트리의 구간을 나타낸다. 예시로 정점 $\text B$를 보자. 정점 $\text B$의 $\text{in}$ 번호와 $\text{out}$ 번호가 각각 1과 5이므로, $\text B$를 루트로 하는 서브 트리의 모든 정점들은 배열에서 1 이상 5 미만의 인덱스 구간에 있다. 이상($\le$)과 미만($&lt;$)에 유의해야 한다.</p>

<p>$$
\text{A, [B, E ,G, F], C, D}
$$</p>

<pre class="mermaid">
    graph TD
    A --&gt; B
    A --&gt; C
    A --&gt; D
    B --&gt; E
    B --&gt; F
    E --&gt; G

    A((A))
    B((B)):::red
    C((C))
    D((D))
    E((E)):::red
    F((F)):::red
    G((G)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>오일러 경로 테크닉은 다시 해석하면 서브 트리들의 모든 정점들을 배열의 인접한 구간에 위치하도록 하는 것이다. 이렇게 만들면 서브 트리 및 조상 정점와 후손 정점 사이에 대한 쿼리를 세그먼트 트리 등을 적용해 쉽게 풀 수 있다.</p>

<h2 id="응용">응용</h2>

<h3 id="후손까지-경로-찾기">후손까지 경로 찾기</h3>

<p>트리의 어떤 정점에서부터 임의의 후손 정점까지의 경로를 찾아야 한다고 해보자. 후손 정점까지 가려면 수많은 자식 정점을 선택하면서 전진해야 할 것이다.</p>

<pre class="mermaid">
    graph TD
        A --&gt; B
        A --&gt; C
        A --&gt; D

    A((Parent))
    B(("Child 1
    <span class="mathjax mj1"></span>"))
    C(("Child 2
    <span class="mathjax mj2"></span>"))
    D(("Child 3
    <span class="mathjax mj3"></span>"))
</pre>
<ol class="mathjax">
    <li class="mj1">$\text{in} = w, \text{out} = x$</li>
    <li class="mj2">$\text{in} = x, \text{out} = y$</li>
    <li class="mj3">$\text{in} = y, \text{out} = z$</li>
</ol>

<p>전진할 자식 정점을 선택하려면 자식 정점들의 $\text{in}$ 번호와 $\text{out}$ 번호가 나타내는 범위를 보면 된다. 탐색하는 정점의 $\text{in}$ 번호를 $m$이라고 하면 자식 정점 중 $m$을 범위에 포함하고 있는 정점로 전진한다. 왜냐하면 $\text{in} \le m &lt; \text{out}$는 곧 그 정점을 서브 트리의 정점로 가지고 있다는 뜻이기 때문이다.</p>

<pre class="mermaid">
    graph TD
        A --&gt; B
        A -- <span class="mathjax mj0"></span> --&gt; C
        A --&gt; D

    A((Parent))
    B(("Child 1
    <span class="mathjax mj1"></span>"))
    C(("Child 2
    <span class="mathjax mj2"></span>")):::red
    D(("Child 3
    <span class="mathjax mj3"></span>"))

    classDef red stroke:#F00, fill:#FEE
</pre>
<ol class="mathjax">
    <li class="mj0">$\text{if }x \le m &lt; y$</li>
    <li class="mj1">$\text{in} = w, \text{out} = x$</li>
    <li class="mj2">$\text{in} = x, \text{out} = y$</li>
    <li class="mj3">$\text{in} = y, \text{out} = z$</li>
</ol>

<p>각 정점 안에서는 자식 정점들이 $\text{in}$ 번호 기준으로 정렬되어 있으므로 해당되는 자식 정점을 선택할 때 이분 탐색을 적용할 수 있다.</p>

<h3 id="최소-공통-조상">최소 공통 조상</h3>

<p>최소 공통 조상 문제는 트리의 어떠한 두 정점이 주어지면 해당 정점들의 가장 가까운 공통 조상을 찾는 문제이다. 이 문제는 오일러 경로 테크닉을 사용하여 $O(\log N)$ 시간만에 해결할 수 있다. 이에 대한 글은 <a href="../../../2024/01/20/lca.html#h-오일러-경로-테크닉">최소 공통 조상</a> 포스트에 있다.</p>

<h3 id="서브-트리에-대한-쿼리">서브 트리에 대한 쿼리</h3>

<p>각 정점이 가중치를 지니고 있는 트리가 있다. 이 트리에서 다음과 같은 문제를 정의할 수 있다.</p>

<blockquote>
  <p>다음 쿼리를 처리하는 프로그램을 작성하라.</p>
  <ol>
    <li><code class="language-plaintext highlighter-rouge">set x v</code>: 정점 <code class="language-plaintext highlighter-rouge">x</code>를 루트로 하는 서브 트리의 모든 정점의 가중치에 <code class="language-plaintext highlighter-rouge">v</code>를 더한다.</li>
    <li><code class="language-plaintext highlighter-rouge">print x</code>: 정점 <code class="language-plaintext highlighter-rouge">x</code>의 가중치를 출력한다.</li>
  </ol>
</blockquote>

<p>1번 쿼리를 DFS로 해결하려 할 경우 매 쿼리마다 $O(N)$이므로 많은 시간이 걸릴 것이다. 이 문제는 오일러 경로 테크닉으로 만든 배열을 lazy propagation 기법을 적용한 세그먼트 트리로 관리하면 풀 수 있다. 임의의 정점의 서브 트리의 모든 정점들은 배열에서 해당 정점의 $\text{in}$ 번호와 $\text{out}$ 번호 사이에 있으므로 이를 배열에서의 구간 쿼리로 해석해 $O(\log N)$만에 쿼리를 수행할 수 있다.</p>

<p>$$
\text{A, [B, E ,G, F], C, D}
$$</p>

<pre class="mermaid">
    graph TD
    A --&gt; B
    A --&gt; C
    A --&gt; D
    B --&gt; E
    B --&gt; F
    E --&gt; G

    A((A))
    B((B)):::red
    C((C))
    D((D))
    E((E)):::red
    F((F)):::red
    G((G)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<h2 id="구현">구현</h2>

<p>오일러 경로 테크닉은 결국 단순 DFS의 결과이므로 구현이 어렵지 않다. 아래 코드는 정점 객체에 오일러 경로 테크닉 함수를 구현한 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 간선으로 연결된 다른 정점들
</span>        <span class="n">self</span><span class="p">.</span><span class="n">in_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 오일러 경로 테크닉으로 생성되는 리스트 반환
</span>    <span class="k">def</span> <span class="nf">euler_tour</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">parent</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">in_num</span> <span class="o">=</span> <span class="n">num</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="nf">euler_tour</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_num</span><span class="p">)</span>  <span class="c1"># 재귀
</span>                <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">out_num</span>
        <span class="k">return</span> <span class="n">array</span>


<span class="c1"># 두 정점의 연결
</span><span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="n">a</span><span class="p">.</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">b</span><span class="p">.</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>루트 정점의 <code class="language-plaintext highlighter-rouge">euler_tour</code> 함수를 호출하면 트리의 모든 정점의 <code class="language-plaintext highlighter-rouge">in_num</code>과 <code class="language-plaintext highlighter-rouge">out_num</code>이 계산되며 그로 인해 만들어지는 배열이 반환된다. 이 배열을 이용해 최소 공통 조상을 구하거나 서브 트리에 대한 쿼리를 처리하는 알고리즘을 구현하는 것은 독자의 몫이다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="트리(trees)" /><category term="오일러_경로_테크닉(euler_tour_technique)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">우선순위 큐, 힙</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/15/priority_queue.html" rel="alternate" type="text/html" title="우선순위 큐, 힙" /><published>2024-01-15T00:00:00+00:00</published><updated>2024-01-15T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/15/priority_queue</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/15/priority_queue.html"><![CDATA[<h2 id="소개">소개</h2>

<p>큐는 삽입과 추출 연산을 지원하는 자료구조이며 추출의 순서는 먼저 삽입된 순서이다. 우선순위 큐란 추출의 순서가 우선순위가 높은 순서인 큐이다. 우선순위 큐는 힙이라는 특수한 트리를 사용하여 삽입과 삭제 연산을 빠르게 수행하도록 구현한다.</p>

<h2 id="원리">원리</h2>

<p>우선 힙을 구성한다. 힙은 부모와 자식 사이의 대소 관계가 일정하게 정해진 완전 이진 트리로 정의한다. 부모와 자식 중 부모 정점이 더 크다면 최대 힙, 부모 정점이 더 작다면 최소 힙이라고 한다. 트리의 대소 관계는 우선순위 큐에서 정의하고 싶은 우선순위대로 설정하면 된다. 아래는 최소 힙의 한 예시이며, 이를 통해서 작은 수부터 추출되는 우선순위 큐의 원리를 살펴보려고 한다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3

    A((11))
    B1((13))
    B2((19))
    C1((17))
    C2((16))
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))
</pre>

<p>위에서 알 수 있듯이 트리의 어떤 정점도 부모 정점보다 작지 않은 것을 볼 수 있다. 이러한 힙은 우선순위 큐에서 지원하는 삽입과 추출 연산에 최적화되어있다. 두 연산의 원리는 이 트리에 새로운 정점을 추가하거나 트리의 루트를 다른 값으로 대체한 후에 힙의 정의를 다시 만족하도록 조작하는 것이다.</p>

<h3 id="삽입">삽입</h3>

<p>힙에 12를 삽입해보자. 우선 힙의 정의와 상관없이 12를 바로 끝 정점 자리에 삽입한다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4

    A((11))
    B1((13))
    B2((19))
    C1((17))
    C2((16))
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))
    D4((12)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>이제 이 트리를 다시 힙의 정의를 만족하도록 수정한다. 우선 정점 12를 부모 정점와 비교하여 힙의 성질을 만족하는 지 검사한다. 만약 힙의 성질을 만족하지 않는다면 해당 정점와 자리를 바꾼다. 현재 이 상황에서는 힙의 성질을 만족하지 않으므로 다음과 같이 자리를 바꾼다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4

    A((11))
    B1((13))
    B2((19))
    C1((17))
    C2((12)):::red
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))
    D4((16))

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>이를 트리가 힙의 성질을 만족할때까지 반복한다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4

    A((11))
    B1((12)):::red
    B2((19))
    C1((17))
    C2((13))
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))
    D4((16))

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>위와 같이 트리가 힙의 성질을 만족하게 되면 연산이 끝난다. 결국에는 이 연산은 새로 삽입한 정점이 루트까지 가거나 그 이전에 끝이 날 것이다. 따라서 전체 정점의 개수를 $N$개라고 한다면 이 연산의 시간복잡도는 $O(\log N)$이다.</p>

<h3 id="추출">추출</h3>

<p>이번에는 힙에서 가장 작은 원소를 제거해보자 (삽입 연산이 완료된 후의 예시를 그대로 인용한다). 가장 작은 원소가 루트에 있다는 사실은 자명하다. 따라서 우선 루트 정점을 제거하고 맨 끝에 있던 정점을 루트의 위치로 옮긴다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3

    A((16)):::green
    B1((12))
    B2((19))
    C1((17))
    C2((13))
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))

    classDef green stroke:#0F0, fill:#EFE
</pre>

<p>이후 트리가 힙의 성질을 만족하도록 수정한다. 해당 정점와 그의 자식 정점을 비교하고 힙의 성질을 만족하지 않을 경우 자식 정점 중 더 작은 정점와 자리를 바꾼다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3

    A((12))
    B1((16)):::green
    B2((19))
    C1((17))
    C2((13))
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))

    classDef green stroke:#0F0, fill:#EFE
</pre>

<p>이를 힙의 성질을 만족할때까지 반복한다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3

    A((12))
    B1((13))
    B2((19))
    C1((17))
    C2((16)):::green
    C3((23))
    C4((25))
    D1((20))
    D2((23))
    D3((17))

    classDef green stroke:#0F0, fill:#EFE
</pre>

<p>위와 같이 힙의 성질을 만족하게 되면 연산이 끝난다. 결국에는 이 연산도 삽입과 마찬가지로 루트에 삽입한 정점이 리프까지 가거나 그 이전에 끝이 날 것이다. 따라서 추출 연산의 시간복잡도도 $O(\log N)$이다. 이와 같이 힙의 성질을 만족하지 않는 트리를 힙의 성질을 만족하도록 해 주는 것을 힙 정렬이라고 한다.</p>

<h2 id="구현">구현</h2>

<p>이 글에서는 최소 힙을 바탕으로 작은 수부터 추출되는 우선순위 큐를 구현할 것이다. 힙은 배열로 구현하는 것이 효율적이다. 배열로 구현할 때는 인덱스를 1부터 시작하도록 하는 것이 더 편리하다. 아래 설명 역시 배열의 인덱스가 1부터 시작한다고 가정한다.</p>

<table>
  <thead>
    <tr>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>위와 같은 배열은 다음과 같은 트리와 대응된다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4

    A((1))
    B1((2))
    B2((3))
    C1((4))
    C2((5))
    C3((6))
    C4((7))
</pre>

<p>신기하게도 $i$번 정점의 자식은 $2i$, $2i + 1$번이다. 이러한 특성은 힙이 완전 이진 트리이기에 가능한 것이다. 따라서 인덱스가 $i$인 정점의 왼쪽 자식의 인덱스는 $2i$, 오른쪽 자식의 인덱스는 $2i + 1$, 부모의 인덱스는 $i/2$임을 이용해 삽입과 추출을 구현할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># 삽입
</span>    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">now</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">now</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span><span class="p">]:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">now</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>

    <span class="c1"># 추출
</span>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">now</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">):</span>
            <span class="n">min_child</span> <span class="o">=</span> <span class="n">now</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">[</span><span class="n">now</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">now</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">)</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">min_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                    <span class="n">min_child</span> <span class="o">=</span> <span class="n">child</span>
            <span class="k">if</span> <span class="n">min_child</span> <span class="o">==</span> <span class="n">now</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">min_child</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">now</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="n">min_child</span><span class="p">]</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">min_child</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 최솟값 확인
</span>    <span class="k">def</span> <span class="nf">peak</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># 비었는지 확인
</span>    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p>두 연산 모두 현재의 정점을 가리키는 변수 <code class="language-plaintext highlighter-rouge">now</code>를 두고 각각 자식 또는 부모 정점와 값을 비교하며 위아래로 움직이는 모양새를 하고 있다.</p>

<h2 id="이용">이용</h2>

<p>우선순위 큐를 이용할 때 번거롭게 매번 구현하는 행위를 없애기 위해 많은 언어에서 기본으로 제공하는 라이브러리를 통해 우선순위 큐를 제공하고 있다.</p>

<table>
  <thead>
    <tr>
      <th>언어</th>
      <th>라이브러리 포함 구문</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C++</td>
      <td><code class="language-plaintext highlighter-rouge">#include &lt;queue&gt;</code></td>
    </tr>
    <tr>
      <td>Java</td>
      <td><code class="language-plaintext highlighter-rouge">import java.util.PriorityQueue</code></td>
    </tr>
    <tr>
      <td>Python</td>
      <td><code class="language-plaintext highlighter-rouge">import heapq</code></td>
    </tr>
  </tbody>
</table>

<p>이들을 사용하기 위해서는 우선순위 큐에 들어가는 원소의 대소 비교가 가능해야 한다. 따라서 해당 언어에서 지원하는 방법으로 원소롤 사용할 자료형의 비교 연산을 오버라이드하거나 우선순위 큐를 선언할 때 비교 정책을 같이 선언해 주는 것이 필요하다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="자료_구조(data_structures)" /><category term="트리(trees)" /><category term="우선순위_큐(priority_queue)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">분리 집합, 서로소 집합</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set.html" rel="alternate" type="text/html" title="분리 집합, 서로소 집합" /><published>2024-01-13T00:00:00+00:00</published><updated>2024-01-13T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set.html"><![CDATA[<h2 id="소개">소개</h2>

<p>분리 집합이란 두 원소를 피연산자로 하는 다음 연산을 지원하는 자료구조이다.</p>

<ol>
  <li>원소가 속한 두 집합을 합치는 연산(Union 연산)</li>
  <li>같은 집합에 속해있는지를 판별하는 연산(Find 연산)</li>
</ol>

<p>분리 집합은 위 둘을 구현하기 위해 트리를 사용한다.</p>

<h2 id="원리">원리</h2>

<p>기본적인 원리는 같은 집합에 있는 원소들을 트리로 엮어 같은 루트를 가지게 하는 것이다. 처음에는 모든 원소가 각각 다른 집합에 있다고 가정한다. 원소들은 자신의 부모를 가리키는 화살표를 하나씩 가지고 있다고 생각하면 된다. 따라서 원소들의 초기 모습은 다음과 같이 자기 자신을 부모로 지정하고 있다. 이들 각각의 루트는 자기 자신이 된다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; B
    C --&gt; C
    D --&gt; D
    E --&gt; E

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>먼저 집합을 합치는 연산을 어떻게 구현할지 생각해보자. 어떠한 두 원소가 같은 집합에 속하게 만드는 것은 두 원소의 루트를 같게 만들어 주는 것이다. 만약 원소 $\text A$와 $\text B$를 같은 집합으로 합친다고 한다면 $\text A$나 $\text B$중 하나의 화살표가 다른 원소를 향하도록 바꾸면 된다. 아래 예시에서는 원소 $\text B$가 원소 $\text A$를 가리키도록 하였다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; C
    D --&gt; D
    E --&gt; E

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>이로서 원소 $\text A$와 $\text B$의 루트가 $\text A$로 같아졌다. 위와 같은 방법으로 다른 원소들도 합쳐서 다음과 같이 $\lbrace \text{A, B} \rbrace$, $\lbrace \text{C, D, E} \rbrace$와 같은 상태가 되었다고 가정하자.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; C
    D --&gt; C
    E --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>위 상황에서 집합을 합치는 연산의 피연산자로 $\text B$와 $\text E$가 들어왔다고 해보자. 원소 $\text B$와 $\text E$가 속한 두 집합을 합칠 땐 원소 $\text B$와 $\text E$ 둘만을 고려하는 것이 아니라 두 원소가 속한 집합에 있는 모든 원소가 같은 집합이 되도록 만들어주어야 한다. 이를 위해서는 화살표를 바꾸는 대상이 원소 $\text B$와 $\text E$ 각각의 루트가 되어야 한다. 따라서 다음과 같이 바꿔주어야 한다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; C
    B --&gt; A
    C --&gt; C
    D --&gt; C
    E --&gt; D

    A((A)):::red
    B((B))
    C((C)):::red
    D((D))
    E((E))

    classDef red stroke:#F00, fill:#FEE
</pre>

<h2 id="구현">구현</h2>

<p>분리 집합을 구현할 때는 원소의 루트를 찾는 <code class="language-plaintext highlighter-rouge">find</code> 함수와 원소의 집합을 합치는 <code class="language-plaintext highlighter-rouge">union</code> 함수로 분할해 구현하는 유니온-파인드(Union-Find) 구현법이 정석이며 구현이 아주 쉽다. 먼저 다음과 같이 원소의 개수를 길이로 갖는 배열을 초기화한다. 이 배열 각각의 인덱스에는 해당 원소의 화살표의 방향, 즉 부모의 인덱스를 담고 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">root</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="union">Union</h3>

<p>집합을 합치는 연산은 아래에서 구현할 <code class="language-plaintext highlighter-rouge">find</code> 함수를 사용해 피연산자로 들어온 두 원소의 루트를 찾고, 그 둘 중 하나의 화살표를 다른 하나를 향하도록 바꿔주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">root</span><span class="p">[</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="큰-집합으로-합치기">큰 집합으로 합치기</h4>

<p>아래와 같이 엄청나게 많은 원소가 루트로 $\text A$를 취하고 있고, 단 한개의 원소 $\text C$만이 원소 $\text B$를 루트로 취하는 상황이 있을 수 있다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; B
    other --&gt; A
    C --&gt; B

    A((A))
    B((B))
    C((C))
    other((many other elements))
</pre>

<p>이 상황에서 두 집합을 합친다고 하면 화살표의 방향을 어떻게 하면 좋을까? 나중을 생각한다면 루트를 찾는 연산의 시간을 최적화하도록 $\text B$에서 $\text A$를 향하도록 바꾸는 것이 나을 것이다. 이를 구현하려면 집합의 크기를 저장하는 변수를 만들어주고 집합을 합칠때마다 이를 갱신해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">small</span><span class="p">,</span> <span class="n">big</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">small</span> <span class="o">!=</span> <span class="n">big</span><span class="p">:</span>
        <span class="n">size</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">big</span>
</code></pre></div></div>

<p>위 코드에서 <code class="language-plaintext highlighter-rouge">size</code> 배열의 각 인덱스에는 해당 원소가 루트일 때의 집합의 크기를 나타낸다. 주의할 점은 해당 원소가 루트일때만 그 값이 유효하다는 것이다.</p>

<h3 id="find">Find</h3>

<p>원소의 루트를 찾는 <code class="language-plaintext highlighter-rouge">find</code> 함수는 다음과 같다. 루트 원소는 화살표가 자기 자신을 향한다는 점을 이용하여 반복문 탈출 조건을 설정하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">n</span>
</code></pre></div></div>

<h4 id="경로-단축">경로 단축</h4>

<p>집합을 합치다보니 다음과 같은 상황이 벌어졌다고 가정하자.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; B
    D --&gt; C
    E --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p><code class="language-plaintext highlighter-rouge">find</code> 함수의 인자로 $\text E$가 계속해서 주어지는 상황이 있을 수 있다. 위 구현의 경우 매 호출시마다 $\text E$에서 부터 $\text A$까지의 원소를 전부 훓어야 한다. 이러한 반복적인 작업을 없애 <code class="language-plaintext highlighter-rouge">find</code> 함수를 최적화할 수 있다. 방법은 해당 원소의 루트를 구할 때마다 다음 그림과 같이 화살표 방향이 바로 루트로 향하도록 갱신해주는 것이다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; A
    D --&gt; A
    E --&gt; A

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>이를 구현하기 위해서 재귀 방식을 사용한다. <code class="language-plaintext highlighter-rouge">find</code> 함수의 호출시마다 매번 화살표 방향의 갱신을 시도함을 볼 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="전체-구현">전체 구현</h3>

<p>위 최적화된 구현을 토대로 한 전체적인 구현은 다음과 같다. 외부 클래스로 한 번 더 감싸고 같은 집합인지를 판별하는 연산을 추가했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">small</span><span class="p">,</span> <span class="n">big</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">small</span> <span class="o">!=</span> <span class="n">big</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">big</span>
    
    <span class="c1"># 같은 집합인지 판별
</span>    <span class="k">def</span> <span class="nf">same_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">union</code> 함수의 시간복잡도는 사실상 <code class="language-plaintext highlighter-rouge">find</code> 함수의 시간복잡도와 같으며, <code class="language-plaintext highlighter-rouge">find</code> 함수의 연산은 최악의 경우의 여러 호출 중 단 한 번 $O(N)$에 그칠 뿐이고 나머지 호출에서는 전부 $O(1)$이다. 따라서 분리 집합을 이용하면 집합 연산을 아주 빠르게 수행할 수 있다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="자료_구조(data_structures)" /><category term="트리(trees)" /><category term="트리_압축(tree_compression)" /><category term="분리_집합(disjoint_set)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">세그먼트 트리, 구간 트리</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/11/segtree.html" rel="alternate" type="text/html" title="세그먼트 트리, 구간 트리" /><published>2024-01-11T00:00:00+00:00</published><updated>2024-01-11T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/11/segtree</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/11/segtree.html"><![CDATA[<h2 id="소개">소개</h2>

<h3 id="문제-제시">문제 제시</h3>

<p>어떠한 배열이 있다. 이 배열의 길이 $N$은 10만 정도이며 수정도 빈번하게 일어난다. 우리는 배열의 임의의 연속된 구간이 주어지면 그 구간의 합을 출력하는 프로그램을 만들 것이다. 우리가 생각해 볼 수 있는 해결법은 단순히 구간의 시작점에서부터 원소들을 더해 출력하는 것이다. 이 경우 매 쿼리마다 시간복잡도가 $O(N)$가 되므로 적절하지 않다. 누군가가 누적 합을 알고 있다면 이 문제에 적용해볼 수 있을 것이다. 그러나 누적 합 방법은 배열의 수정에 $O(N)$의 시간이 걸리므로 이 역시 적절하지 않다. 이 문제를 더 효율적으로 해결하는 자료구조를 생각해 볼 수 있겠는가?</p>

<h3 id="세그먼트-트리">세그먼트 트리</h3>

<p>세그먼트 트리는 갱신이 많이 일어나는 배열의 어떤 구간에 대한 연산 결과를 빠르게 구할 수 있는 자료구조이다. 세그먼트 트리가 지원하는 연산의 종류는 다음과 같다.</p>

<ol>
  <li>배열의 임의의 어떤 구간에 대해 연산(합/곱, 최소/최댓값 등)한다.</li>
  <li>배열의 임의의 인덱스의 값을 수정한다.</li>
</ol>

<p>세그먼트 트리의 원리는 전체 구간을 분할하여 여러 구간들에 대한 연산 결과를 미리 트리 형태로 저장해 사용하는 것이다. 일종의 분할 정복 매커니즘을 사용하여 공간을 더 사용하는 대신 시간을 줄이는 것이다.</p>

<h2 id="원리">원리</h2>

<p>길이가 $N$인 배열의 어떠한 구간 $\left[i, j\right)$에 대해서 그 구간의 모든 원소의 합을 구하는 것을 생각해보자. 만약 $i \le m &lt; j$을 만족하는 어떠한 $m$에 대해서 $\left[i, m\right)$ 구간의 합과 $\left[m, j\right)$ 구간의 합을 미리 알고 있었다면 간단히 그 둘을 더하는 것으로 해당 구간의 합을 구할 수 있다. 우리는 이것을 이용하기 위해 여러 구간들의 합을 미리 계산해 놓을 것이다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4

    A(0 ~ N)
    B1(0 ~ N/2)
    B2(N/2 ~ N)
    C1(0 ~ N/4)
    C2(N/4 ~ 2N/4)
    C3(2N/4 ~ 3N/4)
    C4(3N/4 ~ N)
</pre>

<p>먼저 우리가 전 범위 $\left[0, N\right)$ 구간의 합을 구한다고 생각하자. $\left[0, N\right)$ 구간의 합을 구하기 위해 좌측 절반과 우측 절반의 합을 구하고, 좌측 절반의 합을 구하기 위해 그 범위의 좌측 절반과 우측 절반을 구하는 방식으로 모든 구간에 대해 반복한다. 이것은 구간의 크기가 1이 되어 더이상 절반으로 나눌 수 없을 때까지 반복될 것이다. 이러한 행위는 위 그림처럼 트리로 나타낼 수 있다. 이 트리가 우리가 살펴보고 있는 세그먼트 트리이다.</p>

<h3 id="구간-쿼리">구간 쿼리</h3>

<p>이렇게 트리를 구성하면 임의의 구간의 합을 특별한 방식으로 구할 수 있다. 이해를 돕기 위해 $N = 8$인 예시를 생각해보자. 각 정점들은 해당 구간의 합을 저장하고 있다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7)
    B1(0 ~ 3)
    B2(4 ~ 7)
    C1(0 ~ 1)
    C2(2 ~ 3):::red
    C3(4 ~ 5):::red
    C4(6 ~ 7)
    D1(0)
    D2(1):::red
    D3(2)
    D4(3)
    D5(4)
    D6(5)
    D7(6)
    D8(7)

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>만약 1 ~ 5에 해당하는 구간의 합을 구하려면 어떤 정점을 조사하면 될까? 위 그림의 3개의 빨간색 정점들의 합을 조사하면 것이다. 빨간색 정점에 도달하기 위해서는 트리의 루트에서부터 정점이 나타내는 구간을 바탕으로 DFS를 수행하면 된다. 사실 어떠한 구간을 잡더라도 우리가 조사해야 할 정점의 개수는 $2\log_{2}{N} - 2$을 넘지 않으며, DFS를 통해서 지나온 정점까지 포함하여 계산할 경우 조사할 정점 개수의 최댓값은 $4\log_{2}{N} + \alpha$의 형태를 띤다. 결국 세그먼트 트리를 사용하여 어떠한 구간에 대한 값을 구하는 쿼리의 시간복잡도는 $O(\log N)$이며 이는 구간의 모든 원소를 일일히 참조해 계산하는 시간보다 적다.</p>

<h3 id="원소-갱신">원소 갱신</h3>

<p>이제 배열에서 원소 하나를 갱신하는 상황을 살펴보자. 만약 3번 인덱스의 값을 수정한다면 3번 인덱스를 범위에 포함하는 정점들도 같이 갱신해주어야 할 것이다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7):::green
    B1(0 ~ 3):::green
    B2(4 ~ 7)
    C1(0 ~ 1)
    C2(2 ~ 3):::green
    C3(4 ~ 5)
    C4(6 ~ 7)
    D1(0)
    D2(1)
    D3(2)
    D4(3):::green
    D5(4)
    D6(5)
    D7(6)
    D8(7)

    classDef green stroke:#0F0, fill:#EFE
</pre>

<p>위 그림의 초록색 정점들이 수정 대상이다. 이들은 루트 정점부터 3번 인덱스를 표현하는 리프 정점까지의 경로와 같다. 이들을 갱신하는데는 트리의 높이만큼의 시간이 소요되므로 세그먼트 트리에서 임의의 인덱스의 값을 수정하는 연산의 시간복잡도는 $O(\log N)$이다.</p>

<h2 id="구현">구현</h2>

<p>세그먼트 트리를 구현해보자. 이 글에서는 구간 합을 계산하는 세그먼트 트리를 구현할 것이며, 구간 곱이나 구간 최댓값과 같은 연산을 지원하는 세그먼트 트리 역시 얼마든지 응용하여 구현할 수 있다. 우리가 구현해야 할 것은 세 가지 함수이다.</p>

<ol>
  <li>트리 구축 생성자</li>
  <li>구간 쿼리 함수</li>
  <li>인덱스 갱신 함수</li>
</ol>

<p>세 가지 기능 모두 재귀 함수를 이용한 DFS를 실행하는 함수이다.</p>

<h3 id="트리-구축">트리 구축</h3>

<p>먼저 주어진 배열을 가지고 초기 세그먼트 트리를 구축해야 한다. 이는 재귀 함수를 이용해 루트 정점부터 각 정점의 구간을 정해주면서 전개한다. 아래 코드에서는 해당 정점이 나타내는 구간 $\left[l, r\right)$에 대해 중간값 $m$을 기준으로 왼쪽 범위와 오른쪽 범위의 정점을 가리키는 변수 <code class="language-plaintext highlighter-rouge">left</code>와 <code class="language-plaintext highlighter-rouge">right</code>에 새로운 정점을 만들어 할당해주고 있다. 자식 정점의 생성자를 호출할 때 해당 자식 정점이 나타내는 범위를 인자로 주고 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="구간-쿼리-1">구간 쿼리</h3>

<p>구간 쿼리를 처리하는 함수도 마찬가지로 연산 결과를 구해야 하는 구간 정보와 함께 해당 정점이 나타내는 범위를 인자로 물려주면서 재귀한다. 연산의 대상이 되는 구간 $\left[i, j\right)$과 현재 정점이 나타내는 구간 $\left[l, r\right)$에 대해서 다음과 같이 3가지 경우가 나온다.</p>

<ol>
  <li>$\left[l, r\right)$ 구간이 $\left[i, j\right)$ 구간 안에 포함되는 경우</li>
  <li>$\left[l, r\right)$ 구간이 $\left[i, j\right)$ 구간에 포함되진 않지만 걸쳐있는 경우</li>
  <li>$\left[l, r\right)$ 구간과 $\left[i, j\right)$ 구간이 겹치지 않는 경우</li>
</ol>

<p>1의 경우 정점 자기 자신의 값을 돌려주면 되며, 2의 경우 재귀를 통해 자신의 구간의 연산 값을 구해 돌려주어야 하며, 3의 경우 자기 자신을 연산에 포함시키지 않으면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<h3 id="원소-갱신-1">원소 갱신</h3>

<p>특정 원소를 갱신하는 함수도 마찬가지로 인덱스 번호, 수정할 값과 함께 해당 정점이 나타내는 범위를 인자로 물려주면서 재귀한다. 양 쪽 자식 정점 중 인덱스 번호를 포함하고 있는 방향으로 재귀 호출을 해준다. 리프 정점에서 값을 교체한 후 재귀를 반환하면서 정점들의 값을 갱신해준다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
</code></pre></div></div>

<h3 id="전체-구현">전체 구현</h3>

<p>아래 코드는 전체 코드이다. 위에서 구현한 <code class="language-plaintext highlighter-rouge">Node</code> 클래스를 외부 클래스로 한 번 더 감싼 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="c1"># 구간 쿼리
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># 원소 갱신
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="분할_정복(divide_and_conquer)" /><category term="자료_구조(data_structures)" /><category term="트리(trees)" /><category term="세그먼트_트리(segtree)" /><summary type="html"><![CDATA[소개]]></summary></entry><entry><title type="html">벨만-포드</title><link href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/07/bellman_ford.html" rel="alternate" type="text/html" title="벨만-포드" /><published>2024-01-07T00:00:00+00:00</published><updated>2024-01-07T00:00:00+00:00</updated><id>https://choyunsig.github.io/algorithm_with_boj/post/2024/01/07/bellman_ford</id><content type="html" xml:base="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/07/bellman_ford.html"><![CDATA[<h2 id="소개">소개</h2>

<p>벨만-포드 알고리즘은 그래프상의 한 정점에서 출발점으로 하여 다른 모든 정점에 대해서 최단 경로를 찾는 알고리즘이다. 최단 경로를 찾는 또 다른 알고리즘인 다익스트라와 달리 벨만-포드 알고리즘은 음수 간선을 지닌 그래프에서도 동작한다. 벨만-포드 알고리즘은 그래프의 정점이 $N$개이면 출발점에서 다른 정점들로 가는 모든 단순 경로(한 번 방문한 정점을 다시 방문하지 않는 경로) 중 어느 것도 $N-1$개보다 더 많은 간선을 거칠 수 없음을 이용한다.</p>

<h2 id="원리">원리</h2>

<p>정점의 개수가 $N$인 그래프에서 시작점 $\text A$에 대하여 최단 거리표 $W_{k}$을 다음과 같이 정의하자.</p>

<p>$$
W_{k}[n] \overset{\underset{\mathrm{def}}{}}{=} \left( \displaylines{\text{시작점에서 출발해} \\ \text{간선을 }k\text{개 이하로 거쳐} \\ \text{정점 }n\text{로 가는} \\ \text{최소 경로의 길이}} \right)
$$</p>

<p>만약 그러한 경로가 없을 경우에는 무한대로 간주한다. $W_{0}$은 $W_{0}[A]$만 0으로 초기화하고 나머지 셀은 전부 무한으로 초기화한다. $W_{k}$를 안다고 가정하자. 이를 바탕으로 $W_{k+1}$를 구할 수 있을까? $W_{k+1}$는 $W_{k}$의 경로에서 간선을 한 번 더 지날 수 있게 된 것으로 해석할 수 있다.</p>

<pre class="mermaid">
    graph LR
    A -- <span class="mathjax mj1"></span> --&gt; I
    A -- <span class="mathjax mj2"></span> --&gt; J
    I -- <span class="mathjax mj3"></span> --&gt; J

    A((A))
    I((I))
    J((J))
</pre>
<ol class="mathjax">
    <li class="mj1">$W_{k}[\text I]$</li>
    <li class="mj2">$W_{k}[\text J]$</li>
    <li class="mj3">$c$</li>
</ol>

<p>만약 정점 $\text I$에서 정점 $\text J$로 가는 간선의 가중치가 $c$이고 $W_{k}[\text I] + c &lt; W_{k}[\text J]$라면 (즉 $W_{k}[\text I]$가 함유하는 방법으로 정점 $\text I$로 간 뒤 가중치가 $c$인 간선을 통해 정점 $\text J$로 가는 방법이 기존의 $W_{k}[\text J]$의 방법보다 거리가 짧다면) $W_{k+1}[\text J]$를 $W_{k}[\text I] + c$로 결정할 수 있을 것이다. 이러한 방식으로 $W_{0}$으로부터 $W_{1}$을 구하고, $W_{1}$로부터 $W_{2}$을 구하며, 재귀적으로 $W_{N-1}$을 구할 수 있다. $W_{N-1}$은 $N-1$개 이하의 간선을 거쳐 갈 때의 최단 거리이므로 우리가 구하고자 하는 궁극적인 최단 거리표가 될 것이다.</p>

<p>예시로 이해해보자. 다음과 같은 그래프에 시작점 정점 $\text A$가 있다고 가정하자.</p>

<pre class="mermaid">
    graph LR
    A -- <p style="color: #888">3</p> --&gt; B
    B -- <p style="color: #888">1</p> --&gt; D
    A -- <p style="color: #888">5</p> --&gt; C
    C -- <p style="color: #888">-3</p> --&gt; B

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$W_{0}$</td>
      <td>0</td>
      <td>∞</td>
      <td>∞</td>
      <td>∞</td>
    </tr>
  </tbody>
</table>

<p>$W_{0}$을 바탕으로 $W_{1}$을 구해보자. 정점 $\text A$에서부터 간선을 딱 한 개 거쳐 이동할 수 있는 정점는 $\text B$와 $\text C$가 있으므로 이를 갱신해 줄 수 있다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$W_{1}$</td>
      <td>0</td>
      <td>3</td>
      <td>5</td>
      <td>∞</td>
    </tr>
  </tbody>
</table>

<p>$W_{1}$을 바탕으로 $W_{2}$을 구해보자. $W_{1}$의 방법으로 정점 $\text B$로 간 뒤 간선을 하나 더 거치면 정점 $\text D$로 갈 수 있으므로 이를 갱신해준다. $W_{1}$의 방법으로 정점 $\text C$로 간 뒤 간선을 하나 더 거쳐 정점 $\text B$로 가는 방법은 $W_{1}$의 방법으로 정점 $\text B$로 가는 방법보다 짧다. 따라서 $W_{2}[B] = W_{1}[C] + (-3) = 2$이다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$W_{2}$</td>
      <td>0</td>
      <td>2</td>
      <td>5</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<p>$W_{2}$을 바탕으로 $W_{3}$을 구해보자. 앞서 계산한 $W_{2}[D]$보다 $W_{2}[B] + 1$이 더 짧으므로 $W_{3}[D] = W_{2}[B] + 1 = 3$이다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$W_{3}$</td>
      <td>0</td>
      <td>2</td>
      <td>5</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>이렇게 해서 완성한 $W_{3}$은 이 그래프의 궁극적인 최단 거리표이다.</p>

<h3 id="음수-사이클">음수 사이클</h3>

<p>음수 가중치 그래프에서 최단 경로를 계산할 때의 주의할 점은 해당 그래프가 음수 사이클을 가지고 있을 수 있다는 것이다. 음수 사이클이란 어떠한 한 정점에서 다른 정점을 거쳐 다시 돌아왔을 때 비용이 더 적어지는 경로를 말한다. 다음은 음수 사이클의 한 예이다.</p>

<pre class="mermaid">
    graph LR
    A -- <p style="color: #888">1</p> --&gt; B
    B -- <p style="color: #888">-2</p> --&gt; A
    B -- <p style="color: #888">100</p> --&gt; C

    A((A))
    B((B))
    C((C))
</pre>

<p>정점 $\text A$에서 $\text B$를 거친 후 다시 $\text A$로 오면 총 비용이 1만큼 줄어있다. 이 행위를 무한히 반복하면 총 비용을 음의 무한대로 발산시킬 수 있다. 이 상황에서 정점 $\text A$에서 $\text C$로 가는 최단 경로를 계산해 볼 수 있는가? 결국 이 그래프에서 최단 거리를 재는 것은 무의미하다. 우리가 벨만-포드 알고리즘을 사용하여 계산한 최단 거리도 음수 사이클을 감지하지 못하면 사실은 유효하지 않을 수 있다. (위 그래프를 상대로 벨만-포드 알고리즘을 수행해보라. 적어도 음의 무한대를 표현해 주지는 못한다.) 그러므로 벨만-포드를 사용할 때는 음수 사이클을 감지해 주는 과정이 필수이다.</p>

<p>음수 사이클의 감지는 의외로 간단하다. $W_{N}$을 구한 뒤 $W_{N-1}$과 비교해 갱신이 일어났는지를 검사하면 된다. 만약 그래프가 음수 사이클을 가지고 있지 않다면 $W_{N-1}$은 최단 거리 문제에 대한 이 그래프에서의 최적해이므로 최단 거리를 아무리 갱신해도 변화가 일어나지 않을 것이다. 그래프가 음수 사이클을 가지고 있다면 $W_{N-1}$은 이 그래프에서의 최적해가 아니며 최단 거리가 무한히 갱신될 것이다.</p>

<h2 id="구현">구현</h2>

<p>벨만-포드 알고리즘을 위해서는 그래프를 인접 리스트로 표현하는 것이 좋다. 왜냐하면 그래프의 간선을 기준으로 반복문을 설계할 것이기 때문이다. 먼저 $W_{0}$를 만들고, $W_{N-1}$을 만들기까지의 $N-1$번의 단계와 음수 사이클을 판정하기 위한 1번의 단계를 합하여 총 $N$번의 단계동안 모든 간선을 검사해 최단 거리표를 갱신해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="c1"># edge는 인접 리스트이다.
# edge[n]은 정점 n에서 뻗어나온 모든 간선의 정보를 담은 리스트이다.
# 각 간선은 (다음 정점 번호, 간선의 가중치)의 형태로 표현한다.
</span><span class="k">def</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">start_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">next_node</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span>
                    <span class="c1"># 음수 사이클 판정
</span>                    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">음수 사이클 감지됨</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>정점이 $V$개라고 하면 $V$번의 단계마다 $E$개의 모든 간선을 확인하므로 총 시간복잡도는 $O(VE)$이다.</p>]]></content><author><name>CHOYUNSIG</name></author><category term="post" /><category term="다이나믹_프로그래밍(dp)" /><category term="그래프_이론(graphs)" /><category term="최단_경로(shortest_path)" /><category term="벨만–포드(bellman_ford)" /><summary type="html"><![CDATA[소개]]></summary></entry></feed>