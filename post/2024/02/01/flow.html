<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>유량 그래프와 최대 유량 | APSwBT</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="유량 그래프와 최대 유량">
<meta name="author" content="CHOYUNSIG">
<meta property="og:locale" content="ko">
<meta name="description" content="소개">
<meta property="og:description" content="소개">
<link rel="canonical" href="https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow.html">
<meta property="og:url" content="https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow.html">
<meta property="og:site_name" content="APSwBT">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-02-01T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="유량 그래프와 최대 유량">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CHOYUNSIG"},"dateModified":"2024-02-01T00:00:00+00:00","datePublished":"2024-02-01T00:00:00+00:00","description":"소개","headline":"유량 그래프와 최대 유량","mainEntityOfPage":{"@type":"WebPage","@id":"https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow.html"},"url":"https://choyunsig.github.io/algorithm_with_boj/post/2024/02/01/flow.html"}</script>
<!-- End Jekyll SEO tag -->
<meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/algorithm_with_boj/assets/css/main.css">
  <script src="/algorithm_with_boj/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://choyunsig.github.io/algorithm_with_boj/feed.xml" title="APSwBT">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightElement(block);
  }

  hljs.configure({ignoreUnescapedHTML: true});
  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script type="module">
    // Mathjax 연동
    document.querySelectorAll('.mermaid').forEach( pre => {
        const list = pre.nextElementSibling;
        if (list === null || list.classList[0] !== "mathjax")
            return;
        MathJax.typeset([list]);
        pre.querySelectorAll('span.mathjax').forEach( span => {
            span.outerHTML = "\"<span style=\"color: #888\">" + list.querySelector('.' + span.classList[1]).innerHTML + "</span>\"";
        });
        list.remove();
    });
    // Mermaid 그리기
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'
    mermaid.initialize({
        startOnLoad: false,
    });
    await mermaid.run();
    // Mermaid 노드에 그림자 추가
    document.querySelectorAll('.mermaid').forEach( pre => {
        const current = pre.children[0];
        if (current.ariaRoleDescription !== "flowchart-v2")
            return;
        current.insertAdjacentHTML('afterbegin', `
            <defs>
                <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
                    <feFlood flood-color="black" result="color"/>
                    <feComposite in2="SourceGraphic" in="color" operator="in"/>
                    <feGaussianBlur stdDeviation="3"/>
                    <feComponentTransfer>
                        <feFuncA type="linear" slope="0.5"/>
                    </feComponentTransfer>
                    <feOffset dx="1" dy="2"/>
                    <feMerge>
                        <feMergeNode />
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        `);
        ['rect', 'circle'].map( shape => {
            const drawElement = current.querySelectorAll(shape);
            if (drawElement)
                drawElement.forEach( e => { e.setAttribute("filter", `url(#drop-shadow)`); });
        });
        current.viewBox.baseVal.x -= 8;
        current.viewBox.baseVal.y -= 8;
        current.viewBox.baseVal.width += 10;
        current.viewBox.baseVal.height += 10;
        // Mermaid 기본 정렬 (홈 화면에 적용)
        if (pre.classList.contains("tag-connection-define")) {
            let matrix = new DOMMatrix(window.getComputedStyle(pre).getPropertyValue('transform'));
            current.style.transform = matrix;
            pre.style.transform = 'unset';
        }
    });
</script>

<link rel="apple-touch-icon" sizes="180x180" href="/algorithm_with_boj/assets/images/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/algorithm_with_boj/assets/images/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/algorithm_with_boj/assets/images/icons/favicon-16x16.png">
<link rel="manifest" href="/algorithm_with_boj/assets/images/icons/site.webmanifest">
<link rel="mask-icon" href="/algorithm_with_boj/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;family=Noto+Sans+KR:wght@100..900&amp;display=swap" rel="stylesheet">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/algorithm_with_boj/">
  <img class="site-favicon" title="APSwBT" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/icons/favicon.ico" onerror="this.style.display='none'">
  APSwBT
</a>
</span><div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/algorithm_with_boj/">HOME</a><a class="page-link" href="/algorithm_with_boj/archives.html">POSTS</a><a class="page-link" href="/algorithm_with_boj/tags.html">TAGS</a>
          </div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(https://images.unsplash.com/photo-1568878801942-6fc477a748db?q=80&w=1448&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D);"></div>
        <img class="img-placeholder" src="https://images.unsplash.com/photo-1568878801942-6fc477a748db?q=80&w=1448&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">유량 그래프와 최대 유량</h1>
  <h2 class="post-subtitle">Flow Graph and Maximum Flow</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2024-02-01T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 01, 2024
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> CHOYUNSIG</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 52 mins</span>
  </div>
<div class="post-tags">
<a class="post-tag" href="/algorithm_with_boj/tags.html#%EA%B7%B8%EB%9E%98%ED%94%84_%EC%9D%B4%EB%A1%A0(graphs)">#그래프_이론(graphs)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%EC%B5%9C%EB%8C%80_%EC%9C%A0%EB%9F%89(flow)">#최대_유량(flow)</a>
</div></header>
</div>
      <script>
        document.addEventListener('DOMContentLoaded', function () {
          var pageBannerInner = document.querySelector('.page-banner-inner');

          window.addEventListener('scroll', function () {
            pageBannerInner.style.opacity = Math.max((0.26 * window.innerHeight - window.scrollY) / (0.25 * window.innerHeight), 0);
          });
        });
      </script>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = window.scrollY + element.getBoundingClientRect().top - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<div class="post-related">
      <div>이전 포스트</div>
      <ul>
        
        
        <div>없음</div>
        
      </ul>
    </div>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="post-content e-content" itemprop="articleBody">

    <h2 id="소개">소개</h2>

<p>유량 그래프란 간선에 유량이라는 속성이 있는 그래프이다. 유량은 우리가 생각하는 수도관 파이프로 비유해 이해하면 쉽다. 다음과 같은 그래프에서 모든 간선을 물이 흐르는 파이프이며 모든 정점은 단지 여러 파이프의 연결부라고 생각하자. 간선에 쓰여있는 수들은 해당 간선에 시간당 한 번에 흐를 수 있는 물의 최대 용량(Capacity)이다. 유량 그래프에서 간선에는 방향이 있을 수도 있고 없을 수도 있다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #888">5</p> --&gt; B
    A -- <p style="color: #888">5</p> --&gt; C
    B -- <p style="color: #888">3</p> --&gt; D
    B -- <p style="color: #888">2</p> --&gt; E
    C -- <p style="color: #888">3</p> --&gt; E
    D -- <p style="color: #888">5</p> --&gt; F
    E -- <p style="color: #888">5</p> --&gt; F

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
</pre>

<p>정점 $\text A$가 이 그래프에 물을 공급하는 소스(Source)라고 한다면 정점 $\text F$는 최종적으로 물이 모이는 싱크(Sink)가 된다. 유량 그래프에서 흐르는 물을 흔히 유량(Flow)이라고 표현한다. 이 글에서도 그래프에 흐르는 물을 유량이라고 표현하겠다. 이 유량은 각 라우터 간의 트래픽 볼륨으로도 비유할 수 있다. 그래서 유량 그래프는 네트워크 분야에서 흔히 사용된다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #F00">1/5</p> --&gt; B
    A -- <p style="color: #888">0/5</p> --&gt; C
    B -- <p style="color: #888">0/3</p> --&gt; D
    B -- <p style="color: #F00">1/2</p> --&gt; E
    C -- <p style="color: #888">0/3</p> --&gt; E
    D -- <p style="color: #888">0/5</p> --&gt; F
    E -- <p style="color: #F00">1/5</p> --&gt; F

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
</pre>

<p>만약 정점 $\text A$에 시간당 1 만큼의 유량이 나온다면 정점 $\text F$에는 시간당 얼마만큼의 유량이 쏟아질까? 간선의 용량들이 여유로우므로 당연히 1 만큼의 유량이 모두 정점 $\text F$에 도달한다. 위의 그림은 정점 $\text A$에서 $\text F$로 1의 유량이 흐르는 한 예시이다. 꼭 현실 세계처럼 모든 파이프에 잔잔하게 유량이 흐르지 않아도 되며 유량이 다음 속성을 지키기만 한다면 어떠한 경로든 유량을 흘려도 괜찮다.</p>

<ol>
  <li>유한성: 간선의 유량은 반드시 간선의 용량보다 작거나 같다. 즉 간선의 용량에서 간선의 유량을 뺀 값은 항상 0보다 크거나 같다.</li>
  <li>대칭성: $u$에서 $v$로 유량 $f$이 흐르는 것은 $v$에서 $u$로 유량 $-f$이 흐르는 것과 같다.</li>
  <li>보존성: 소스와 싱크를 제외한 모든 정점에서 들어온 유량의 합과 나가는 유량의 합이 같다.</li>
</ol>

<p>특히 대칭성은 나중에 설명할 최대 유량 문제를 푸는 데 유용하게 쓰이는 성질이다.</p>

<h3 id="구현">구현</h3>

<p>유량 그래프를 구현해보자. 각 간선과 정점을 객체로 만들고 외부 클래스로 감쌌다. 아래 구현은 객체지향적 구현으로 성능을 중시하는 구현과는 거리가 멀다는 것을 참고하기 바란다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="c1"># 간선
</span>    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 간선에 연결된 노드를 반환
</span>        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># 간선의 잔여 용량을 반환
</span>        <span class="k">def</span> <span class="nf">get_remain</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>
        
        <span class="c1"># 간선에 유량을 흘림
</span>        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>
    
    <span class="c1"># 정점
</span>    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 생성자, 그래프의 크기와 소스 및 싱크를 입력받음
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">source</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">sink</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span>

    <span class="c1"># 두 정점을 간선으로 이음
</span>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
</code></pre></div></div>

<p>여기서 간선의 구현에 주목하자. 간선의 각 함수들인 <code class="language-plaintext highlighter-rouge">get_node</code>, <code class="language-plaintext highlighter-rouge">get_remain</code>, <code class="language-plaintext highlighter-rouge">give_flow</code>는 호출 시 인자로 받은 정점에 따라 해당 간선의 정보를 다르게 계산하고 있다. 왜냐하면 유량의 대칭성에 의해 간선의 시작점 방향에서 바라봤을 때와 간선의 도착점 방향에서 바라봤을 때의 간선의 잔여 용량이 다르기 때문이다. 이는 최대 유량 문제의 해결에서 더 자세히 다룬다.</p>

<h2 id="최대-유량-문제">최대 유량 문제</h2>

<p>여기서 다음과 같은 문제를 생각해 볼 수 있다. 만약 정점 $\text A$에 시간당 무한대의 유량이 나온다면 정점 $\text F$에는 시간당 얼만큼의 유량이 도달하게 될까? 간선이 허용하는 용량 선에서 정점 $\text F$에 유량이 도달할 것은 분명하다. 직접 그림을 그려 계산해보면 다음과 같이 정점 $\text F$에는 최대 8의 유량이 닿는다는 것을 볼 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #888">5/5</p> --&gt; B
    A -- <p style="color: #888">3/5</p> --&gt; C
    B -- <p style="color: #888">3/3</p> --&gt; D
    B -- <p style="color: #888">2/2</p> --&gt; E
    C -- <p style="color: #888">3/3</p> --&gt; E
    D -- <p style="color: #888">3/5</p> --&gt; F
    E -- <p style="color: #888">5/5</p> --&gt; F

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
</pre>

<p>이처럼 유량 그래프의 소스에서 무한대의 유량이 나온다고 가정했을 때 싱크에 도달할 수 있는 최대 유량을 구하는 문제를 최대 유량 문제라고 한다. 어떠한 유량 그래프가 주어졌을 때 싱크로 흐르는 최대 유량을 구할 때 고려해야 할 사항이 엄청 많아 보인다. 임의의 유량 그래프에서 최대 유량 문제를 어떻게 해결할 수 있을까?</p>

<h3 id="포드-풀커슨">포드-풀커슨</h3>

<p>해결법은 그래프에 유량이 더 이상 흐를 수 없을때까지 유량을 소량씩 흘려보내는 것을 반복하는 것이다. 즉, 다음과 같은 절차를 반복한다.</p>

<ol>
  <li>용량이 남아있는 간선을 따라 소스부터 싱크까지 가는 증가 경로(augmenting path)를 찾는다. 찾지 못할 경우 종료한다.</li>
  <li>찾은 경로를 따라 흘릴 수 있는 최대의 유량을 흘린다.</li>
</ol>

<p>아래 예시를 통해 이해해보자. 다음과 같이 정점 $\text A$가 소스, 정점 $\text D$가 싱크인 유량 그래프가 있다. 우리는 눈으로 간단히 이 그래프의 최대 유량이 10임을 알 수 있다. 과연 그 해답이 위 절차를 반복함으로서 도출되는 지 알아보자.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">0/5</p> .-&gt; B
    B -. <p style="color: #888">0/2</p> .-&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -. <p style="color: #888">0/5</p> .-&gt; D
    C -. <p style="color: #888">0/5</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>위 유량 그래프에서 증가 경로를 다음과 같이 찾을 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #888">0/5</p> --&gt; B
    B -- <p style="color: #888">0/2</p> --&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -. <p style="color: #888">0/5</p> .-&gt; D
    C -- <p style="color: #888">0/5</p> --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>찾은 경로에 유량을 흘린다. 위 경로를 통해 최대로 흘릴 수 있는 유량이 2이므로 2의 유량을 흘려준다.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #F00">2/5</p> .-&gt; B
    B -. <p style="color: #F00">2/2</p> .-&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -. <p style="color: #888">0/5</p> .-&gt; D
    C -. <p style="color: #F00">2/5</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 다시 증가 경로를 찾는 단계로 되돌아간다. 이러한 단계를 더 이상 증가 경로가 보이지 않을때까지 반복한다.</p>

<pre class="mermaid">
    graph LR

    A -- <p style="color: #F00">5/5</p> --&gt; B
    B -. <p style="color: #888">2/2</p> .-&gt; C
    A -. <p style="color: #888">0/5</p> .-&gt; C
    B -- <p style="color: #F00">3/5</p> --&gt; D
    C -. <p style="color: #888">2/5</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>
<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">5/5</p> .-&gt; B
    B -. <p style="color: #888">2/2</p> .-&gt; C
    A -- <p style="color: #F00">3/5</p> --&gt; C
    B -. <p style="color: #888">3/5</p> .-&gt; D
    C -- <p style="color: #F00">5/5</p> --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 위 그래프에서 증가 경로를 찾을 수 있는가? 우리 눈에는 증가 경로를 찾을 수 없지만 분명 이 그래프의 최대 유량이 8이 아닌 10이라는 것은 알고 있다. 그렇다면 숨겨진 증가 경로가 있는 것일까? 그렇다. 이는 유량의 대칭성을 이용하면 된다. 우선 각 간선들의 반대 방향으로 용량이 0인 간선을 추가로 그어준다. 이와 같은 간선이 유량 그래프의 최대 유량에 영향을 미치지 않음은 직관적으로 알 수 있다. 이제 유량의 대칭성에 의해 유량을 흘려준 간선의 반대 방향으로 같은 양의 음의 유량을 흘려 주었다고 생각하고 다시 그래프를 그려보자.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">정방향: 5/5\n<span style="color: #00F">역방향: -5/0</span></p> .-&gt; B
    B -. <p style="color: #888">정방향: 2/2\n<span style="color: #00F">역방향: -2/0</span></p> .-&gt; C
    A -. <p style="color: #888">정방향: 3/5\n<span style="color: #00F">역방향: -3/0</span></p> .-&gt; C
    B -. <p style="color: #888">정방향: 3/5\n<span style="color: #00F">역방향: -3/0</span></p> .-&gt; D
    C -. <p style="color: #888">정방향: 5/5\n<span style="color: #00F">역방향: -5/0</span></p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 증가 경로가 보일 것이다. 다음과 같은 경로는 간선의 잔여 용량, 즉 간선의 총 용량에서 현재 흐르고 있는 유량을 뺀 값이 양수인 간선만을 이용해 소스에서 싱크로 가고 있으므로 증가 경로라고 할 수 있다.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; B
    B -- <p style="color: #888">정방향: 2/2\n<span style="color: #F00">역방향: -2/0</span></p> --&gt; C
    A -- <p style="color: #888"><span style="color: #F00">정방향: 3/5</span>\n역방향: -3/0</p> --&gt; C
    B -- <p style="color: #888"><span style="color: #F00">정방향: 3/5</span>\n역방향: -3/0</p> --&gt; D
    C -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 유량을 흘려준다.</p>

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; B
    B -. <p style="color: #F00">정방향: 0/2\n역방향: 0/0</p> .-&gt; C
    A -. <p style="color: #F00">정방향: 5/5\n역방향: -5/0</p> .-&gt; C
    B -. <p style="color: #F00">정방향: 5/5\n역방향: -5/0</p> .-&gt; D
    C -. <p style="color: #888">정방향: 5/5\n역방향: -5/0</p> .-&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
</pre>

<p>이제 더 이상 증가 경로를 찾을 수 없으므로 종료가 된다. 종료가 되고 나면 이 그래프의 최대 유량이 10이라는 것을 알 수 있다. 이렇듯 유량의 대칭성을 이용해 숨겨진 증가 경로까지 전부 찾아내어 더 이상 유량이 흐를 수 없을때까지 그래프를 포화시켰을 때의 유량이 해당 그래프의 최대 유량이다. 이러한 방법을 포드-풀커슨 방법이라고 한다.</p>

<h4 id="구현-1">구현</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">count</span>

<span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_residual</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>

        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>

    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span> <span class="ow">is</span> <span class="n">sink</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">min_residual</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="n">residual</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_residual</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="ow">and</span> <span class="n">residual</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span>
                    <span class="n">flow</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">edge</span><span class="p">.</span><span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">flow</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ford_fulkerson</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">flow</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">Graph</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">],</span> <span class="n">INF</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">flow</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>포드-풀커슨 방법의 시간복잡도는 간선이 가질 수 있는 용량의 범위에 비례해 영향을 받는다. 왜냐하면 매번 흘리는 유량의 값이 최소 1이므로 최대 $F$번의 DFS 탐색이 필요하기 때문이다. 따라서 그래프의 정점의 개수를 $V$, 간선의 개수를 $E$, 간선 용량의 최댓값 $F$라 하면 포드-풀커슨 방법의 시간복잡도는 $O((V + E)F)$이다.</p>

<h4 id="에드몬드-카프">에드몬드-카프</h4>

<p>에드몬드-카프 알고리즘은 포드-풀커슨 방법의 일종이며 기존 포드-풀커슨 방법과 다른 점은 DFS 대신 BFS를 사용하여 간선이 적은 그래프에서 빠르게 작동한다는 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_residual</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>

        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>

    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visited_by</span><span class="p">:</span> <span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">min_residual</span> <span class="o">=</span> <span class="n">INF</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">edmonds_karp</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">]])</span>
            <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">Graph</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">now</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="n">residual</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_residual</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span> <span class="ow">and</span> <span class="n">residual</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">visited_by</span> <span class="o">=</span> <span class="n">edge</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">min_residual</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">now</span><span class="p">.</span><span class="n">min_residual</span><span class="p">)</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">min_residual</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">now</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">visited_by</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                <span class="n">now</span><span class="p">.</span><span class="n">visited_by</span><span class="p">.</span><span class="nf">give_flow</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">min_residual</span><span class="p">)</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">pre</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>에드몬드-카프 알고리즘은 정점의 개수가 $V$, 간선의 개수가 $E$인 그래프에서 BFS의 횟수가 많아야 $VE$번이라는 것이 증명되어 있다. 따라서 에드몬드-카프 알고리즘의 시간복잡도는 $O(VE^2)$이다.</p>

<h3 id="디닉">디닉</h3>

<p>디닉 알고리즘은 최대 유량을 레벨 그래프(Level Graph)의 개념을 적용하여 빠르게 구하는 알고리즘이다. 레벨 그래프란 각 정점에 잔여 용량이 있는 간선만을 이용해 BFS를 수행할 때 방문 깊이를 구하고, 잔여 용량이 남아있으면서 깊이가 1만큼 차이나는 정점을 잇는 간선만을 남겨놓은 그래프이다. 다음 예제로 디닉 알고리즘의 작동 절차를 설명하겠다. 이 예시는 <a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm">영문 위키피디아</a> 자료를 그대로 가져온 것이며 디닉 알고리즘을 설명할 때 아주 많이 쓰인다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Dinic_algorithm_G1.svg/1920px-Dinic_algorithm_G1.svg.png" style="background-color: white"></p>

<p>우선 레벨 그래프를 구축한다. 즉, 잔여 용량이 남은 간선을 이용해 BFS를 수행하면서 정점마다 방문 깊이를 저장하고 깊이가 1만큼 차이나는 정점을 잇는 간선만을 남겨둔다. 그 후 이 그래프를 특화된 DFS를 이용해 소스부터 싱크까지의 경로를 찾고 유량을 흘려준다. 이 떄 흘려준 유량을 차단 유량(Blocking Flow)이라고 한다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/Dinic_algorithm_GL1.svg/1920px-Dinic_algorithm_GL1.svg.png" style="background-color: white"></p>

<p>이것이 디닉 알고리즘의 한 단계이다. 한 단계를 끝마친 후 그래프의 모습은 아래와 같다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Dinic_algorithm_G2.svg/1920px-Dinic_algorithm_G2.svg.png" style="background-color: white"></p>

<p>한 단계를 더 수행해본다. 즉, 다시 레벨 그래프를 구축하고 차단 유량을 흘린다. 아래 레벨 그래프 그림은 잔여 용량을 간선의 원래 용량처럼 보고 레벨 그래프를 그린 것이다.</p>

<div style="column-count: 2; margin-bottom: 16px">
    <img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Dinic_algorithm_GL2.svg/1920px-Dinic_algorithm_GL2.svg.png" style="background-color: white">
    <img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Dinic_algorithm_G3.svg/1920px-Dinic_algorithm_G3.svg.png" style="background-color: white">
</div>

<p>한 단계를 더 반복해 레벨 그래프를 구축하면 다음과 같이 더 이상 싱크까지 레벨 그래프를 구축할 수 없다. 이렇게 되면 디닉 알고리즘은 끝이 난다.</p>

<p><img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Dinic_algorithm_GL3.svg/1920px-Dinic_algorithm_GL3.svg.png" style="background-color: white"></p>

<p>디닉 알고리즘은 정점의 개수가 $V$, 간선의 개수가 $E$인 그래프에서 최대 $O(V)$번의 단계가 시행될 수 있으며, 각 단계에서 차단 유량을 찾는 데 걸리는 시간복잡도가 $O(VE)$임이 알려져 있다. 따라서 디닉 알고리즘의 시간복잡도는 $O(V^2E)$이다.</p>

<h4 id="구현-2">구현</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">INF</span> <span class="o">=</span> <span class="mi">1_000_000_000</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_remain</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">return </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">flow</span>

        <span class="k">def</span> <span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">flow</span>

    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">self</span><span class="p">.</span><span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="sh">'</span><span class="s">Graph.Node</span><span class="sh">'</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span> <span class="ow">is</span> <span class="n">sink</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">min_residual</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pivot</span><span class="p">:]:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="n">remain</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_remain</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">level</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">flow</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">dfs</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">remain</span><span class="p">,</span> <span class="n">min_residual</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">edge</span><span class="p">.</span><span class="nf">give_flow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">flow</span>
                <span class="n">self</span><span class="p">.</span><span class="n">pivot</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">Graph</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">.</span><span class="nc">Edge</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dinic</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sink</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">visit_id</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">Graph</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
            <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">]])</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">now</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_node</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="n">remain</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="nf">get_remain</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">visit_id</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">node</span><span class="p">.</span><span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">].</span><span class="n">visit_id</span> <span class="o">!=</span> <span class="n">visit_id</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">flow</span><span class="p">:</span>
                <span class="n">flow</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">source</span><span class="p">].</span><span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node</span><span class="p">[</span><span class="n">sink</span><span class="p">],</span> <span class="n">INF</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">flow</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>


  </div>

  <script>
    // h2 태그를 제목으로 하고 있는 본문을 div로 묶음
    var postContentDiv = document.querySelector('div.post-content');
    var divContainer = [];

    while (postContentDiv.children.length > 0) {
      var currentElement = postContentDiv.children[0];
      if (currentElement.tagName.toLowerCase() === 'h2') {
        var newDiv = document.createElement('div');
        newDiv.classList.add('post-section');
        divContainer.push(newDiv);
      }
      divContainer[divContainer.length - 1].appendChild(currentElement);
    }

    for (var i = 0; i < divContainer.length; i++) {
      postContentDiv.appendChild(divContainer[i]);
    }
  </script>

  <script>
    // 포스트 내 테이블의 overflow 방지 및 margin 추가
    var postContentDiv = document.querySelector('div.post-content');
    var tables = postContentDiv.querySelectorAll('table');
    tables.forEach(function(table) {
      var div = document.createElement('div');
      div.classList.add('post-table');
      table.parentNode.replaceChild(div, table);
      div.appendChild(table);
    });
  </script><script>/*
    터치 스크롤 적용

    사용:
    Liquid 용법으로 사용됨
    include touch-scroller.html container="element.class"

    주의사항:
    터치 스크롤을 적용하려는 요소와 그것을 감싼 Container 요소가 반드시 직계 부모-자식 관계여야 함
    부모의 padding 값은 px 단위로 지정되어야 함
    자식의 overflow 값이 hidden으로 지정되어야 함
    */

    try {
        let scrollBefore = { translateX: 0, translateY: 0 };
        let scrollTarget = undefined;
        let scrollStart = { x: 0, y: 0 };
        let scrolling = false;
        let scrolled = false;

        function getPos(event) {
            var x = event.clientX;
            var y = event.clientY;
            if (x === undefined || y === undefined) {
                x = event.changedTouches[0].clientX;
                y = event.changedTouches[0].clientY;
            }
            return { 'x': x, 'y': y };
        }

        function onScrollStart(event) {
            const target = event.target.closest('pre.highlight');
            if (!target)
                return false;
            event.stopPropagation();
            scrollStart = getPos(event);
            var matrix = new DOMMatrix(window.getComputedStyle(target.children[0]).getPropertyValue('transform'));
            if (matrix === "none")
                matrix = new DOMMatrix('matrix(1, 0, 0, 1, 0, 0)');
            scrollBefore.translateX = matrix.m41;
            scrollBefore.translateY = matrix.m42;
            scrollTarget = target.children[0];
            scrolling = true;
            scrolled = false;
        }

        function onScrollMove(event) {
            if (!scrolling)
                return false;
            const pos = getPos(event);
            const style = window.getComputedStyle(scrollTarget.parentElement);
            let padX = parseFloat(style.getPropertyValue('padding-right')) + parseFloat(style.getPropertyValue('padding-right'));
            let padY = parseFloat(style.getPropertyValue('padding-top')) + parseFloat(style.getPropertyValue('padding-bottom'));
            const translateX = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().width - scrollTarget.parentElement.getBoundingClientRect().width + padX), Math.min(0, scrollBefore.translateX - (scrollStart.x - pos.x)));
            const translateY = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().height - scrollTarget.parentElement.getBoundingClientRect().height + padY), Math.min(0, scrollBefore.translateY - (scrollStart.y - pos.y)));
            if (!scrolled && (translateX - scrollBefore.translateX) ** 2 + (translateY - scrollBefore.translateY) ** 2 < 1) {
                scrolling = false;
                return;
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            scrollTarget.style.transform = `translate(${translateX}px, ${translateY}px)`;
            scrolled = true;
        }

        function onScrollEnd(event) {
            event.stopPropagation();
            scrolling = false;
            scrolled = false;
        }

        function onClick(event) {
            if (scrolled)
                event.preventDefault();
            return false;
        }
    }
    catch {
        // 두 번 이상 include 할 경우 여기에 표시
    }

    document.querySelectorAll('pre.highlight').forEach( pre => {
        pre.addEventListener("click", onClick);
        pre.addEventListener("mousedown", onScrollStart);
        pre.addEventListener("touchstart", onScrollStart);
        pre.addEventListener("touchmove", onScrollMove);
        pre.addEventListener("touchend", onScrollEnd);
    });
    window.addEventListener("mousemove", onScrollMove);
    window.addEventListener("mouseup", onScrollEnd);
</script></article>
<div class="post-related">
      <div>다음 포스트</div>
      <ul>
        
        
        <div>없음</div>
        
      </ul>
    </div>
  </section>
</div>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">Index</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 50;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/algorithm_with_boj/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Made by <a href="https://github.com/CHOYUNSIG">CHOYUNSIG</a>
</div>
      <div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>
</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/algorithm_with_boj/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
