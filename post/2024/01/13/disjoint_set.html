<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>분리 집합, 서로소 집합 | APSwBT</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="분리 집합, 서로소 집합">
<meta name="author" content="CHOYUNSIG">
<meta property="og:locale" content="ko">
<meta name="description" content="소개">
<meta property="og:description" content="소개">
<link rel="canonical" href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set.html">
<meta property="og:url" content="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set.html">
<meta property="og:site_name" content="APSwBT">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-01-13T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="분리 집합, 서로소 집합">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CHOYUNSIG"},"dateModified":"2024-01-13T00:00:00+00:00","datePublished":"2024-01-13T00:00:00+00:00","description":"소개","headline":"분리 집합, 서로소 집합","mainEntityOfPage":{"@type":"WebPage","@id":"https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set.html"},"url":"https://choyunsig.github.io/algorithm_with_boj/post/2024/01/13/disjoint_set.html"}</script>
<!-- End Jekyll SEO tag -->
<meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/algorithm_with_boj/assets/css/main.css">
  <script src="/algorithm_with_boj/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://choyunsig.github.io/algorithm_with_boj/feed.xml" title="APSwBT">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightElement(block);
  }

  hljs.configure({ignoreUnescapedHTML: true});
  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script type="module">
    // Mathjax 연동
    document.querySelectorAll('.mermaid').forEach( pre => {
        const list = pre.nextElementSibling;
        if (list === null || list.classList[0] !== "mathjax")
            return;
        MathJax.typeset([list]);
        pre.querySelectorAll('span.mathjax').forEach( span => {
            span.outerHTML = "\"<span style=\"color: #888\">" + list.querySelector('.' + span.classList[1]).innerHTML + "</span>\"";
        });
        list.remove();
    });
    // Mermaid 그리기
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'
    mermaid.initialize({
        startOnLoad: false,
    });
    await mermaid.run();
    // Mermaid 노드에 그림자 추가
    document.querySelectorAll('.mermaid').forEach( pre => {
        const current = pre.children[0];
        if (current.ariaRoleDescription !== "flowchart-v2")
            return;
        current.insertAdjacentHTML('afterbegin', `
            <defs>
                <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
                    <feFlood flood-color="black" result="color"/>
                    <feComposite in2="SourceGraphic" in="color" operator="in"/>
                    <feGaussianBlur stdDeviation="3"/>
                    <feComponentTransfer>
                        <feFuncA type="linear" slope="0.5"/>
                    </feComponentTransfer>
                    <feOffset dx="1" dy="2"/>
                    <feMerge>
                        <feMergeNode />
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        `);
        ['rect', 'circle'].map( shape => {
            const drawElement = current.querySelectorAll(shape);
            if (drawElement)
                drawElement.forEach( e => { e.setAttribute("filter", `url(#drop-shadow)`); });
        });
        current.viewBox.baseVal.x -= 8;
        current.viewBox.baseVal.y -= 8;
        current.viewBox.baseVal.width += 10;
        current.viewBox.baseVal.height += 10;
        // Mermaid 기본 정렬 (홈 화면에 적용)
        if (pre.classList.contains("tag-connection-define")) {
            let matrix = new DOMMatrix(window.getComputedStyle(pre).getPropertyValue('transform'));
            current.style.transform = matrix;
            pre.style.transform = 'unset';
        }
    });
</script>

<link rel="apple-touch-icon" sizes="180x180" href="/algorithm_with_boj/assets/images/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/algorithm_with_boj/assets/images/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/algorithm_with_boj/assets/images/icons/favicon-16x16.png">
<link rel="manifest" href="/algorithm_with_boj/assets/images/icons/site.webmanifest">
<link rel="mask-icon" href="/algorithm_with_boj/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;family=Noto+Sans+KR:wght@100..900&amp;display=swap" rel="stylesheet">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/algorithm_with_boj/">
  <img class="site-favicon" title="APSwBT" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/icons/favicon.ico" onerror="this.style.display='none'">
  APSwBT
</a>
</span><div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/algorithm_with_boj/">HOME</a><a class="page-link" href="/algorithm_with_boj/archives.html">POSTS</a><a class="page-link" href="/algorithm_with_boj/tags.html">TAGS</a>
          </div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(https://images.unsplash.com/photo-1481026469463-66327c86e544?q=80&w=1508&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D);"></div>
        <img class="img-placeholder" src="https://images.unsplash.com/photo-1481026469463-66327c86e544?q=80&w=1508&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">분리 집합, 서로소 집합</h1>
  <h2 class="post-subtitle">Disjoint Set</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2024-01-13T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 13, 2024
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> CHOYUNSIG</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 15 mins</span>
  </div>
<div class="post-tags">
<a class="post-tag" href="/algorithm_with_boj/tags.html#%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0(data_structures)">#자료_구조(data_structures)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%ED%8A%B8%EB%A6%AC(trees)">#트리(trees)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%ED%8A%B8%EB%A6%AC_%EC%95%95%EC%B6%95(tree_compression)">#트리_압축(tree_compression)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%EB%B6%84%EB%A6%AC_%EC%A7%91%ED%95%A9(disjoint_set)">#분리_집합(disjoint_set)</a>
</div></header>
</div>
      <script>
        document.addEventListener('DOMContentLoaded', function () {
          var pageBannerInner = document.querySelector('.page-banner-inner');

          window.addEventListener('scroll', function () {
            pageBannerInner.style.opacity = Math.max((0.26 * window.innerHeight - window.scrollY) / (0.25 * window.innerHeight), 0);
          });
        });
      </script>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = window.scrollY + element.getBoundingClientRect().top - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<div class="post-related">
      <div>이전 포스트</div>
      <ul>
        
        
        <div>없음</div>
        
      </ul>
    </div>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="post-content e-content" itemprop="articleBody">

    <h2 id="소개">소개</h2>

<p>분리 집합이란 두 원소를 피연산자로 하는 다음 연산을 지원하는 자료구조이다.</p>

<ol>
  <li>원소가 속한 두 집합을 합치는 연산(Union 연산)</li>
  <li>같은 집합에 속해있는지를 판별하는 연산(Find 연산)</li>
</ol>

<p>분리 집합은 위 둘을 구현하기 위해 트리를 사용한다.</p>

<h2 id="원리">원리</h2>

<p>기본적인 원리는 같은 집합에 있는 원소들을 트리로 엮어 같은 루트를 가지게 하는 것이다. 처음에는 모든 원소가 각각 다른 집합에 있다고 가정한다. 원소들은 자신의 부모를 가리키는 화살표를 하나씩 가지고 있다고 생각하면 된다. 따라서 원소들의 초기 모습은 다음과 같이 자기 자신을 부모로 지정하고 있다. 이들 각각의 루트는 자기 자신이 된다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; B
    C --&gt; C
    D --&gt; D
    E --&gt; E

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>먼저 집합을 합치는 연산을 어떻게 구현할지 생각해보자. 어떠한 두 원소가 같은 집합에 속하게 만드는 것은 두 원소의 루트를 같게 만들어 주는 것이다. 만약 원소 $\text A$와 $\text B$를 같은 집합으로 합친다고 한다면 $\text A$나 $\text B$중 하나의 화살표가 다른 원소를 향하도록 바꾸면 된다. 아래 예시에서는 원소 $\text B$가 원소 $\text A$를 가리키도록 하였다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; C
    D --&gt; D
    E --&gt; E

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>이로서 원소 $\text A$와 $\text B$의 루트가 $\text A$로 같아졌다. 위와 같은 방법으로 다른 원소들도 합쳐서 다음과 같이 $\lbrace \text{A, B} \rbrace$, $\lbrace \text{C, D, E} \rbrace$와 같은 상태가 되었다고 가정하자.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; C
    D --&gt; C
    E --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>위 상황에서 집합을 합치는 연산의 피연산자로 $\text B$와 $\text E$가 들어왔다고 해보자. 원소 $\text B$와 $\text E$가 속한 두 집합을 합칠 땐 원소 $\text B$와 $\text E$ 둘만을 고려하는 것이 아니라 두 원소가 속한 집합에 있는 모든 원소가 같은 집합이 되도록 만들어주어야 한다. 이를 위해서는 화살표를 바꾸는 대상이 원소 $\text B$와 $\text E$ 각각의 루트가 되어야 한다. 따라서 다음과 같이 바꿔주어야 한다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; C
    B --&gt; A
    C --&gt; C
    D --&gt; C
    E --&gt; D

    A((A)):::red
    B((B))
    C((C)):::red
    D((D))
    E((E))

    classDef red stroke:#F00, fill:#FEE
</pre>

<h2 id="구현">구현</h2>

<p>분리 집합을 구현할 때는 원소의 루트를 찾는 <code class="language-plaintext highlighter-rouge">find</code> 함수와 원소의 집합을 합치는 <code class="language-plaintext highlighter-rouge">union</code> 함수로 분할해 구현하는 유니온-파인드(Union-Find) 구현법이 정석이며 구현이 아주 쉽다. 먼저 다음과 같이 원소의 개수를 길이로 갖는 배열을 초기화한다. 이 배열 각각의 인덱스에는 해당 원소의 화살표의 방향, 즉 부모의 인덱스를 담고 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">root</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="union">Union</h3>

<p>집합을 합치는 연산은 아래에서 구현할 <code class="language-plaintext highlighter-rouge">find</code> 함수를 사용해 피연산자로 들어온 두 원소의 루트를 찾고, 그 둘 중 하나의 화살표를 다른 하나를 향하도록 바꿔주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">root</span><span class="p">[</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="큰-집합으로-합치기">큰 집합으로 합치기</h4>

<p>아래와 같이 엄청나게 많은 원소가 루트로 $\text A$를 취하고 있고, 단 한개의 원소 $\text C$만이 원소 $\text B$를 루트로 취하는 상황이 있을 수 있다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; B
    other --&gt; A
    C --&gt; B

    A((A))
    B((B))
    C((C))
    other((many other elements))
</pre>

<p>이 상황에서 두 집합을 합친다고 하면 화살표의 방향을 어떻게 하면 좋을까? 나중을 생각한다면 루트를 찾는 연산의 시간을 최적화하도록 $\text B$에서 $\text A$를 향하도록 바꾸는 것이 나을 것이다. 이를 구현하려면 집합의 크기를 저장하는 변수를 만들어주고 집합을 합칠때마다 이를 갱신해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">small</span><span class="p">,</span> <span class="n">big</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">small</span> <span class="o">!=</span> <span class="n">big</span><span class="p">:</span>
        <span class="n">size</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span>
        <span class="n">root</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">big</span>
</code></pre></div></div>

<p>위 코드에서 <code class="language-plaintext highlighter-rouge">size</code> 배열의 각 인덱스에는 해당 원소가 루트일 때의 집합의 크기를 나타낸다. 주의할 점은 해당 원소가 루트일때만 그 값이 유효하다는 것이다.</p>

<h3 id="find">Find</h3>

<p>원소의 루트를 찾는 <code class="language-plaintext highlighter-rouge">find</code> 함수는 다음과 같다. 루트 원소는 화살표가 자기 자신을 향한다는 점을 이용하여 반복문 탈출 조건을 설정하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">n</span>
</code></pre></div></div>

<h4 id="경로-단축">경로 단축</h4>

<p>집합을 합치다보니 다음과 같은 상황이 벌어졌다고 가정하자.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; B
    D --&gt; C
    E --&gt; D

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p><code class="language-plaintext highlighter-rouge">find</code> 함수의 인자로 $\text E$가 계속해서 주어지는 상황이 있을 수 있다. 위 구현의 경우 매 호출시마다 $\text E$에서 부터 $\text A$까지의 원소를 전부 훓어야 한다. 이러한 반복적인 작업을 없애 <code class="language-plaintext highlighter-rouge">find</code> 함수를 최적화할 수 있다. 방법은 해당 원소의 루트를 구할 때마다 다음 그림과 같이 화살표 방향이 바로 루트로 향하도록 갱신해주는 것이다.</p>

<pre class="mermaid">
    graph BT
    A --&gt; A
    B --&gt; A
    C --&gt; A
    D --&gt; A
    E --&gt; A

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
</pre>

<p>이를 구현하기 위해서 재귀 방식을 사용한다. <code class="language-plaintext highlighter-rouge">find</code> 함수의 호출시마다 매번 화살표 방향의 갱신을 시도함을 볼 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="전체-구현">전체 구현</h3>

<p>위 최적화된 구현을 토대로 한 전체적인 구현은 다음과 같다. 외부 클래스로 한 번 더 감싸고 같은 집합인지를 판별하는 연산을 추가했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">small</span><span class="p">,</span> <span class="n">big</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">small</span> <span class="o">!=</span> <span class="n">big</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">big</span>
    
    <span class="c1"># 같은 집합인지 판별
</span>    <span class="k">def</span> <span class="nf">same_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">union</code> 함수의 시간복잡도는 사실상 <code class="language-plaintext highlighter-rouge">find</code> 함수의 시간복잡도와 같으며, <code class="language-plaintext highlighter-rouge">find</code> 함수의 연산은 최악의 경우의 여러 호출 중 단 한 번 $O(N)$에 그칠 뿐이고 나머지 호출에서는 전부 $O(1)$이다. 따라서 분리 집합을 이용하면 집합 연산을 아주 빠르게 수행할 수 있다.</p>


  </div>

  <script>
    // h2 태그를 제목으로 하고 있는 본문을 div로 묶음
    var postContentDiv = document.querySelector('div.post-content');
    var divContainer = [];

    while (postContentDiv.children.length > 0) {
      var currentElement = postContentDiv.children[0];
      if (currentElement.tagName.toLowerCase() === 'h2') {
        var newDiv = document.createElement('div');
        newDiv.classList.add('post-section');
        divContainer.push(newDiv);
      }
      divContainer[divContainer.length - 1].appendChild(currentElement);
    }

    for (var i = 0; i < divContainer.length; i++) {
      postContentDiv.appendChild(divContainer[i]);
    }
  </script>

  <script>
    // 포스트 내 테이블의 overflow 방지 및 margin 추가
    var postContentDiv = document.querySelector('div.post-content');
    var tables = postContentDiv.querySelectorAll('table');
    tables.forEach(function(table) {
      var div = document.createElement('div');
      div.classList.add('post-table');
      table.parentNode.replaceChild(div, table);
      div.appendChild(table);
    });
  </script><script>/*
    터치 스크롤 적용

    사용:
    Liquid 용법으로 사용됨
    include touch-scroller.html container="element.class"

    주의사항:
    터치 스크롤을 적용하려는 요소와 그것을 감싼 Container 요소가 반드시 직계 부모-자식 관계여야 함
    부모의 padding 값은 px 단위로 지정되어야 함
    자식의 overflow 값이 hidden으로 지정되어야 함
    */

    try {
        let scrollBefore = { translateX: 0, translateY: 0 };
        let scrollTarget = undefined;
        let scrollStart = { x: 0, y: 0 };
        let scrolling = false;
        let scrolled = false;

        function getPos(event) {
            var x = event.clientX;
            var y = event.clientY;
            if (x === undefined || y === undefined) {
                x = event.changedTouches[0].clientX;
                y = event.changedTouches[0].clientY;
            }
            return { 'x': x, 'y': y };
        }

        function onScrollStart(event) {
            const target = event.target.closest('pre.highlight');
            if (!target)
                return false;
            event.stopPropagation();
            scrollStart = getPos(event);
            var matrix = new DOMMatrix(window.getComputedStyle(target.children[0]).getPropertyValue('transform'));
            if (matrix === "none")
                matrix = new DOMMatrix('matrix(1, 0, 0, 1, 0, 0)');
            scrollBefore.translateX = matrix.m41;
            scrollBefore.translateY = matrix.m42;
            scrollTarget = target.children[0];
            scrolling = true;
            scrolled = false;
        }

        function onScrollMove(event) {
            if (!scrolling)
                return false;
            const pos = getPos(event);
            const style = window.getComputedStyle(scrollTarget.parentElement);
            let padX = parseFloat(style.getPropertyValue('padding-right')) + parseFloat(style.getPropertyValue('padding-right'));
            let padY = parseFloat(style.getPropertyValue('padding-top')) + parseFloat(style.getPropertyValue('padding-bottom'));
            const translateX = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().width - scrollTarget.parentElement.getBoundingClientRect().width + padX), Math.min(0, scrollBefore.translateX - (scrollStart.x - pos.x)));
            const translateY = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().height - scrollTarget.parentElement.getBoundingClientRect().height + padY), Math.min(0, scrollBefore.translateY - (scrollStart.y - pos.y)));
            if (!scrolled && (translateX - scrollBefore.translateX) ** 2 + (translateY - scrollBefore.translateY) ** 2 < 1) {
                scrolling = false;
                return;
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            scrollTarget.style.transform = `translate(${translateX}px, ${translateY}px)`;
            scrolled = true;
        }

        function onScrollEnd(event) {
            event.stopPropagation();
            scrolling = false;
            scrolled = false;
        }

        function onClick(event) {
            if (scrolled)
                event.preventDefault();
            return false;
        }
    }
    catch {
        // 두 번 이상 include 할 경우 여기에 표시
    }

    document.querySelectorAll('pre.highlight').forEach( pre => {
        pre.addEventListener("click", onClick);
        pre.addEventListener("mousedown", onScrollStart);
        pre.addEventListener("touchstart", onScrollStart);
        pre.addEventListener("touchmove", onScrollMove);
        pre.addEventListener("touchend", onScrollEnd);
    });
    window.addEventListener("mousemove", onScrollMove);
    window.addEventListener("mouseup", onScrollEnd);
</script></article>
<div class="post-related">
      <div>다음 포스트</div>
      <ul>
        
        
        <div>없음</div>
        
      </ul>
    </div>
  </section>
</div>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">Index</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 50;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/algorithm_with_boj/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Made by <a href="https://github.com/CHOYUNSIG">CHOYUNSIG</a>
</div>
      <div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>
</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/algorithm_with_boj/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
