<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>오일러 경로 테크닉 | APSwBT</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="오일러 경로 테크닉">
<meta name="author" content="CHOYUNSIG">
<meta property="og:locale" content="ko">
<meta name="description" content="소개">
<meta property="og:description" content="소개">
<link rel="canonical" href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique.html">
<meta property="og:url" content="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique.html">
<meta property="og:site_name" content="APSwBT">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-01-18T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="오일러 경로 테크닉">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CHOYUNSIG"},"dateModified":"2024-01-18T00:00:00+00:00","datePublished":"2024-01-18T00:00:00+00:00","description":"소개","headline":"오일러 경로 테크닉","mainEntityOfPage":{"@type":"WebPage","@id":"https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique.html"},"url":"https://choyunsig.github.io/algorithm_with_boj/post/2024/01/18/euler_tour_technique.html"}</script>
<!-- End Jekyll SEO tag -->
<meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/algorithm_with_boj/assets/css/main.css">
  <script src="/algorithm_with_boj/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://choyunsig.github.io/algorithm_with_boj/feed.xml" title="APSwBT">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightElement(block);
  }

  hljs.configure({ignoreUnescapedHTML: true});
  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script type="module">
    // Mathjax 연동
    document.querySelectorAll('.mermaid').forEach( pre => {
        const list = pre.nextElementSibling;
        if (list === null || list.classList[0] !== "mathjax")
            return;
        MathJax.typeset([list]);
        pre.querySelectorAll('span.mathjax').forEach( span => {
            span.outerHTML = "\"<span style=\"color: #888\">" + list.querySelector('.' + span.classList[1]).innerHTML + "</span>\"";
        });
        list.remove();
    });
    // Mermaid 그리기
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'
    mermaid.initialize({
        startOnLoad: false,
    });
    await mermaid.run();
    // Mermaid 노드에 그림자 추가
    document.querySelectorAll('.mermaid').forEach( pre => {
        const current = pre.children[0];
        if (current.ariaRoleDescription !== "flowchart-v2")
            return;
        current.insertAdjacentHTML('afterbegin', `
            <defs>
                <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
                    <feFlood flood-color="black" result="color"/>
                    <feComposite in2="SourceGraphic" in="color" operator="in"/>
                    <feGaussianBlur stdDeviation="3"/>
                    <feComponentTransfer>
                        <feFuncA type="linear" slope="0.5"/>
                    </feComponentTransfer>
                    <feOffset dx="1" dy="2"/>
                    <feMerge>
                        <feMergeNode />
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        `);
        ['rect', 'circle'].map( shape => {
            const drawElement = current.querySelectorAll(shape);
            if (drawElement)
                drawElement.forEach( e => { e.setAttribute("filter", `url(#drop-shadow)`); });
        });
        current.viewBox.baseVal.x -= 8;
        current.viewBox.baseVal.y -= 8;
        current.viewBox.baseVal.width += 10;
        current.viewBox.baseVal.height += 10;
        // Mermaid 기본 정렬 (홈 화면에 적용)
        if (pre.classList.contains("tag-connection-define")) {
            let matrix = new DOMMatrix(window.getComputedStyle(pre).getPropertyValue('transform'));
            current.style.transform = matrix;
            pre.style.transform = 'unset';
        }
    });
</script>

<link rel="apple-touch-icon" sizes="180x180" href="/algorithm_with_boj/assets/images/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/algorithm_with_boj/assets/images/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/algorithm_with_boj/assets/images/icons/favicon-16x16.png">
<link rel="manifest" href="/algorithm_with_boj/assets/images/icons/site.webmanifest">
<link rel="mask-icon" href="/algorithm_with_boj/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;family=Noto+Sans+KR:wght@100..900&amp;display=swap" rel="stylesheet">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/algorithm_with_boj/">
  <img class="site-favicon" title="APSwBT" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/icons/favicon.ico" onerror="this.style.display='none'">
  APSwBT
</a>
</span><div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/algorithm_with_boj/">HOME</a><a class="page-link" href="/algorithm_with_boj/archives.html">POSTS</a><a class="page-link" href="/algorithm_with_boj/tags.html">TAGS</a>
          </div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(https://images.unsplash.com/photo-1460317442991-0ec209397118?q=80&w=1470&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D);"></div>
        <img class="img-placeholder" src="https://images.unsplash.com/photo-1460317442991-0ec209397118?q=80&w=1470&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">오일러 경로 테크닉</h1>
  <h2 class="post-subtitle">Euler Tour Technique</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2024-01-18T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 18, 2024
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> CHOYUNSIG</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 15 mins</span>
  </div>
<div class="post-tags">
<a class="post-tag" href="/algorithm_with_boj/tags.html#%ED%8A%B8%EB%A6%AC(trees)">#트리(trees)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%EC%98%A4%EC%9D%BC%EB%9F%AC_%EA%B2%BD%EB%A1%9C_%ED%85%8C%ED%81%AC%EB%8B%89(euler_tour_technique)">#오일러_경로_테크닉(euler_tour_technique)</a>
</div></header>
</div>
      <script>
        document.addEventListener('DOMContentLoaded', function () {
          var pageBannerInner = document.querySelector('.page-banner-inner');

          window.addEventListener('scroll', function () {
            pageBannerInner.style.opacity = Math.max((0.26 * window.innerHeight - window.scrollY) / (0.25 * window.innerHeight), 0);
          });
        });
      </script>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = window.scrollY + element.getBoundingClientRect().top - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<div class="post-related">
      <div>이전 포스트</div>
      <ul>
        
        
        <div>없음</div>
        
      </ul>
    </div>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="post-content e-content" itemprop="articleBody">

    <h2 id="소개">소개</h2>

<p>트리는 비선형 자료구조다. 비선형이라고 함은 적어도 2차원 상에서 생각해야 한다는 것이다. 오일러 경로 테크닉은 비선형 자료구조인 트리를 다루기 쉬운 선형 자료구조로 환원하는 방법을 제시한다. 오일러 경로 테크닉이라고 해서 오일러 경로에 대한 정의나 오일러 경로를 구하는 알고리즘을 알 필요는 없다.</p>

<h2 id="원리">원리</h2>

<p>오일러 경로 테크닉은 쉽게 말해서 DFS로 정점에 순서를 부여하고 그 순서대로 나열하는 것이다. 아래 트리를 오일러 경로 테크닉을 통해 정점에 순서를 부여해보자.</p>

<div style="column-count: 2">
    <pre class="mermaid">
        graph TD
        A --&gt; B
        A --&gt; C
        A --&gt; D
        B --&gt; E
        B --&gt; F
        E --&gt; G

        A((A))
        B((B))
        C((C))
        D((D))
        E((E))
        F((F))
        G((G))
    </pre>

    <img class="post-image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Stirling_permutation_Euler_tour.svg/306px-Stirling_permutation_Euler_tour.svg.png" style="background-color: white">
</div>

<p>위 트리를 옆의 그림과 같이 DFS 방식으로 순회하면서 각 정점에 총 두 개의 번호 $\text{in}$, $\text{out}$을 부여한다. $\text{in}$은 DFS를 하면서 정점에 방문한 순서이고, $\text{out}$은 해당 정점을 탈출하는 시점에서 다음으로 방문할 정점에 부여할 $\text{in}$ 번호이다. 번호를 전부 매기면 다음과 같이 될 것이다.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>$\text A$</th>
      <th>$\text B$</th>
      <th>$\text C$</th>
      <th>$\text D$</th>
      <th>$\text E$</th>
      <th>$\text F$</th>
      <th>$\text G$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\text{in}$</td>
      <td>0</td>
      <td>1</td>
      <td>5</td>
      <td>6</td>
      <td>2</td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <td>$\text{out}$</td>
      <td>7</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>4</td>
      <td>5</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<p>정점들을 $\text{in}$ 번호 순서대로 나열하고 배열을 만들어보자. 각 정점의 $\text{in}$ 번호가 이 배열에서의 인덱스와 일치한다.</p>

<p>$$
\left[\text{A, B, E ,G, F, C, D}\right]
$$</p>

<p>$\text{in}$ 번호와 $\text{out}$ 번호는 무엇을 의미할까? 신기하게도 어떠한 정점 $\text X$를 루트로 하는 서브 트리의 모든 정점는 $\text X$의 $\text{in}$ 번호와 $\text{out}$ 번호의 사이에 있다. 즉 $\text{in}$ 번호와 $\text{out}$ 번호는 서브 트리의 구간을 나타낸다. 예시로 정점 $\text B$를 보자. 정점 $\text B$의 $\text{in}$ 번호와 $\text{out}$ 번호가 각각 1과 5이므로, $\text B$를 루트로 하는 서브 트리의 모든 정점들은 배열에서 1 이상 5 미만의 인덱스 구간에 있다. 이상($\le$)과 미만($&lt;$)에 유의해야 한다.</p>

<p>$$
\text{A, [B, E ,G, F], C, D}
$$</p>

<pre class="mermaid">
    graph TD
    A --&gt; B
    A --&gt; C
    A --&gt; D
    B --&gt; E
    B --&gt; F
    E --&gt; G

    A((A))
    B((B)):::red
    C((C))
    D((D))
    E((E)):::red
    F((F)):::red
    G((G)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>오일러 경로 테크닉은 다시 해석하면 서브 트리들의 모든 정점들을 배열의 인접한 구간에 위치하도록 하는 것이다. 이렇게 만들면 서브 트리 및 조상 정점와 후손 정점 사이에 대한 쿼리를 세그먼트 트리 등을 적용해 쉽게 풀 수 있다.</p>

<h2 id="응용">응용</h2>

<h3 id="후손까지-경로-찾기">후손까지 경로 찾기</h3>

<p>트리의 어떤 정점에서부터 임의의 후손 정점까지의 경로를 찾아야 한다고 해보자. 후손 정점까지 가려면 수많은 자식 정점을 선택하면서 전진해야 할 것이다.</p>

<pre class="mermaid">
    graph TD
        A --&gt; B
        A --&gt; C
        A --&gt; D

    A((Parent))
    B(("Child 1
    <span class="mathjax mj1"></span>"))
    C(("Child 2
    <span class="mathjax mj2"></span>"))
    D(("Child 3
    <span class="mathjax mj3"></span>"))
</pre>
<ol class="mathjax">
    <li class="mj1">$\text{in} = w, \text{out} = x$</li>
    <li class="mj2">$\text{in} = x, \text{out} = y$</li>
    <li class="mj3">$\text{in} = y, \text{out} = z$</li>
</ol>

<p>전진할 자식 정점을 선택하려면 자식 정점들의 $\text{in}$ 번호와 $\text{out}$ 번호가 나타내는 범위를 보면 된다. 탐색하는 정점의 $\text{in}$ 번호를 $m$이라고 하면 자식 정점 중 $m$을 범위에 포함하고 있는 정점로 전진한다. 왜냐하면 $\text{in} \le m &lt; \text{out}$는 곧 그 정점을 서브 트리의 정점로 가지고 있다는 뜻이기 때문이다.</p>

<pre class="mermaid">
    graph TD
        A --&gt; B
        A -- <span class="mathjax mj0"></span> --&gt; C
        A --&gt; D

    A((Parent))
    B(("Child 1
    <span class="mathjax mj1"></span>"))
    C(("Child 2
    <span class="mathjax mj2"></span>")):::red
    D(("Child 3
    <span class="mathjax mj3"></span>"))

    classDef red stroke:#F00, fill:#FEE
</pre>
<ol class="mathjax">
    <li class="mj0">$\text{if }x \le m &lt; y$</li>
    <li class="mj1">$\text{in} = w, \text{out} = x$</li>
    <li class="mj2">$\text{in} = x, \text{out} = y$</li>
    <li class="mj3">$\text{in} = y, \text{out} = z$</li>
</ol>

<p>각 정점 안에서는 자식 정점들이 $\text{in}$ 번호 기준으로 정렬되어 있으므로 해당되는 자식 정점을 선택할 때 이분 탐색을 적용할 수 있다.</p>

<h3 id="최소-공통-조상">최소 공통 조상</h3>

<p>최소 공통 조상 문제는 트리의 어떠한 두 정점이 주어지면 해당 정점들의 가장 가까운 공통 조상을 찾는 문제이다. 이 문제는 오일러 경로 테크닉을 사용하여 $O(\log N)$ 시간만에 해결할 수 있다. 이에 대한 글은 <a href="../../../2024/01/20/lca.html#h-%EC%98%A4%EC%9D%BC%EB%9F%AC-%EA%B2%BD%EB%A1%9C-%ED%85%8C%ED%81%AC%EB%8B%89">최소 공통 조상</a> 포스트에 있다.</p>

<h3 id="서브-트리에-대한-쿼리">서브 트리에 대한 쿼리</h3>

<p>각 정점이 가중치를 지니고 있는 트리가 있다. 이 트리에서 다음과 같은 문제를 정의할 수 있다.</p>

<blockquote>
  <p>다음 쿼리를 처리하는 프로그램을 작성하라.</p>
  <ol>
    <li>
<code class="language-plaintext highlighter-rouge">set x v</code>: 정점 <code class="language-plaintext highlighter-rouge">x</code>를 루트로 하는 서브 트리의 모든 정점의 가중치에 <code class="language-plaintext highlighter-rouge">v</code>를 더한다.</li>
    <li>
<code class="language-plaintext highlighter-rouge">print x</code>: 정점 <code class="language-plaintext highlighter-rouge">x</code>의 가중치를 출력한다.</li>
  </ol>
</blockquote>

<p>1번 쿼리를 DFS로 해결하려 할 경우 매 쿼리마다 $O(N)$이므로 많은 시간이 걸릴 것이다. 이 문제는 오일러 경로 테크닉으로 만든 배열을 lazy propagation 기법을 적용한 세그먼트 트리로 관리하면 풀 수 있다. 임의의 정점의 서브 트리의 모든 정점들은 배열에서 해당 정점의 $\text{in}$ 번호와 $\text{out}$ 번호 사이에 있으므로 이를 배열에서의 구간 쿼리로 해석해 $O(\log N)$만에 쿼리를 수행할 수 있다.</p>

<p>$$
\text{A, [B, E ,G, F], C, D}
$$</p>

<pre class="mermaid">
    graph TD
    A --&gt; B
    A --&gt; C
    A --&gt; D
    B --&gt; E
    B --&gt; F
    E --&gt; G

    A((A))
    B((B)):::red
    C((C))
    D((D))
    E((E)):::red
    F((F)):::red
    G((G)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

<h2 id="구현">구현</h2>

<p>오일러 경로 테크닉은 결국 단순 DFS의 결과이므로 구현이 어렵지 않다. 아래 코드는 정점 객체에 오일러 경로 테크닉 함수를 구현한 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 간선으로 연결된 다른 정점들
</span>        <span class="n">self</span><span class="p">.</span><span class="n">in_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 오일러 경로 테크닉으로 생성되는 리스트 반환
</span>    <span class="k">def</span> <span class="nf">euler_tour</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">parent</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">]:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">in_num</span> <span class="o">=</span> <span class="n">num</span>
        <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edge</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="nf">euler_tour</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">out_num</span><span class="p">)</span>  <span class="c1"># 재귀
</span>                <span class="n">self</span><span class="p">.</span><span class="n">out_num</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">out_num</span>
        <span class="k">return</span> <span class="n">array</span>


<span class="c1"># 두 정점의 연결
</span><span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
    <span class="n">a</span><span class="p">.</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">b</span><span class="p">.</span><span class="n">edge</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>루트 정점의 <code class="language-plaintext highlighter-rouge">euler_tour</code> 함수를 호출하면 트리의 모든 정점의 <code class="language-plaintext highlighter-rouge">in_num</code>과 <code class="language-plaintext highlighter-rouge">out_num</code>이 계산되며 그로 인해 만들어지는 배열이 반환된다. 이 배열을 이용해 최소 공통 조상을 구하거나 서브 트리에 대한 쿼리를 처리하는 알고리즘을 구현하는 것은 독자의 몫이다.</p>


  </div>

  <script>
    // h2 태그를 제목으로 하고 있는 본문을 div로 묶음
    var postContentDiv = document.querySelector('div.post-content');
    var divContainer = [];

    while (postContentDiv.children.length > 0) {
      var currentElement = postContentDiv.children[0];
      if (currentElement.tagName.toLowerCase() === 'h2') {
        var newDiv = document.createElement('div');
        newDiv.classList.add('post-section');
        divContainer.push(newDiv);
      }
      divContainer[divContainer.length - 1].appendChild(currentElement);
    }

    for (var i = 0; i < divContainer.length; i++) {
      postContentDiv.appendChild(divContainer[i]);
    }
  </script>

  <script>
    // 포스트 내 테이블의 overflow 방지 및 margin 추가
    var postContentDiv = document.querySelector('div.post-content');
    var tables = postContentDiv.querySelectorAll('table');
    tables.forEach(function(table) {
      var div = document.createElement('div');
      div.classList.add('post-table');
      table.parentNode.replaceChild(div, table);
      div.appendChild(table);
    });
  </script><script>/*
    터치 스크롤 적용

    사용:
    Liquid 용법으로 사용됨
    include touch-scroller.html container="element.class"

    주의사항:
    터치 스크롤을 적용하려는 요소와 그것을 감싼 Container 요소가 반드시 직계 부모-자식 관계여야 함
    부모의 padding 값은 px 단위로 지정되어야 함
    자식의 overflow 값이 hidden으로 지정되어야 함
    */

    try {
        let scrollBefore = { translateX: 0, translateY: 0 };
        let scrollTarget = undefined;
        let scrollStart = { x: 0, y: 0 };
        let scrolling = false;
        let scrolled = false;

        function getPos(event) {
            var x = event.clientX;
            var y = event.clientY;
            if (x === undefined || y === undefined) {
                x = event.changedTouches[0].clientX;
                y = event.changedTouches[0].clientY;
            }
            return { 'x': x, 'y': y };
        }

        function onScrollStart(event) {
            const target = event.target.closest('pre.highlight');
            if (!target)
                return false;
            event.stopPropagation();
            scrollStart = getPos(event);
            var matrix = new DOMMatrix(window.getComputedStyle(target.children[0]).getPropertyValue('transform'));
            if (matrix === "none")
                matrix = new DOMMatrix('matrix(1, 0, 0, 1, 0, 0)');
            scrollBefore.translateX = matrix.m41;
            scrollBefore.translateY = matrix.m42;
            scrollTarget = target.children[0];
            scrolling = true;
            scrolled = false;
        }

        function onScrollMove(event) {
            if (!scrolling)
                return false;
            const pos = getPos(event);
            const style = window.getComputedStyle(scrollTarget.parentElement);
            let padX = parseFloat(style.getPropertyValue('padding-right')) + parseFloat(style.getPropertyValue('padding-right'));
            let padY = parseFloat(style.getPropertyValue('padding-top')) + parseFloat(style.getPropertyValue('padding-bottom'));
            const translateX = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().width - scrollTarget.parentElement.getBoundingClientRect().width + padX), Math.min(0, scrollBefore.translateX - (scrollStart.x - pos.x)));
            const translateY = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().height - scrollTarget.parentElement.getBoundingClientRect().height + padY), Math.min(0, scrollBefore.translateY - (scrollStart.y - pos.y)));
            if (!scrolled && (translateX - scrollBefore.translateX) ** 2 + (translateY - scrollBefore.translateY) ** 2 < 1) {
                scrolling = false;
                return;
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            scrollTarget.style.transform = `translate(${translateX}px, ${translateY}px)`;
            scrolled = true;
        }

        function onScrollEnd(event) {
            event.stopPropagation();
            scrolling = false;
            scrolled = false;
        }

        function onClick(event) {
            if (scrolled)
                event.preventDefault();
            return false;
        }
    }
    catch {
        // 두 번 이상 include 할 경우 여기에 표시
    }

    document.querySelectorAll('pre.highlight').forEach( pre => {
        pre.addEventListener("click", onClick);
        pre.addEventListener("mousedown", onScrollStart);
        pre.addEventListener("touchstart", onScrollStart);
        pre.addEventListener("touchmove", onScrollMove);
        pre.addEventListener("touchend", onScrollEnd);
    });
    window.addEventListener("mousemove", onScrollMove);
    window.addEventListener("mouseup", onScrollEnd);
</script></article>
<div class="post-related">
      <div>다음 포스트</div>
      <ul>
        
        
        <li class="">
          <a class="post-link" href="/algorithm_with_boj/post/2024/01/20/lca.html" title="최소 공통 조상">
            최소 공통 조상
            
          </a>
        </li>
      </ul>
    </div>
  </section>
</div>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">Index</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 50;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/algorithm_with_boj/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Made by <a href="https://github.com/CHOYUNSIG">CHOYUNSIG</a>
</div>
      <div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>
</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/algorithm_with_boj/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
