<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>퍼시스턴트 세그먼트 트리 | APSwBT</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="퍼시스턴트 세그먼트 트리">
<meta name="author" content="CHOYUNSIG">
<meta property="og:locale" content="ko">
<meta name="description" content="소개">
<meta property="og:description" content="소개">
<link rel="canonical" href="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst.html">
<meta property="og:url" content="https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst.html">
<meta property="og:site_name" content="APSwBT">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-01-30T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="퍼시스턴트 세그먼트 트리">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CHOYUNSIG"},"dateModified":"2024-01-30T00:00:00+00:00","datePublished":"2024-01-30T00:00:00+00:00","description":"소개","headline":"퍼시스턴트 세그먼트 트리","mainEntityOfPage":{"@type":"WebPage","@id":"https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst.html"},"url":"https://choyunsig.github.io/algorithm_with_boj/post/2024/01/30/pst.html"}</script>
<!-- End Jekyll SEO tag -->
<meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/algorithm_with_boj/assets/css/main.css">
  <script src="/algorithm_with_boj/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://choyunsig.github.io/algorithm_with_boj/feed.xml" title="APSwBT">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightElement(block);
  }

  hljs.configure({ignoreUnescapedHTML: true});
  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script type="module">
    // Mathjax 연동
    document.querySelectorAll('.mermaid').forEach( pre => {
        const list = pre.nextElementSibling;
        if (list === null || list.classList[0] !== "mathjax")
            return;
        MathJax.typeset([list]);
        pre.querySelectorAll('span.mathjax').forEach( span => {
            span.outerHTML = "\"<span style=\"color: #888\">" + list.querySelector('.' + span.classList[1]).innerHTML + "</span>\"";
        });
        list.remove();
    });
    // Mermaid 그리기
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'
    mermaid.initialize({
        startOnLoad: false,
    });
    await mermaid.run();
    // Mermaid 노드에 그림자 추가
    document.querySelectorAll('.mermaid').forEach( pre => {
        const current = pre.children[0];
        if (current.ariaRoleDescription !== "flowchart-v2")
            return;
        current.insertAdjacentHTML('afterbegin', `
            <defs>
                <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
                    <feFlood flood-color="black" result="color"/>
                    <feComposite in2="SourceGraphic" in="color" operator="in"/>
                    <feGaussianBlur stdDeviation="3"/>
                    <feComponentTransfer>
                        <feFuncA type="linear" slope="0.5"/>
                    </feComponentTransfer>
                    <feOffset dx="1" dy="2"/>
                    <feMerge>
                        <feMergeNode />
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
        `);
        ['rect', 'circle'].map( shape => {
            const drawElement = current.querySelectorAll(shape);
            if (drawElement)
                drawElement.forEach( e => { e.setAttribute("filter", `url(#drop-shadow)`); });
        });
        current.viewBox.baseVal.x -= 8;
        current.viewBox.baseVal.y -= 8;
        current.viewBox.baseVal.width += 10;
        current.viewBox.baseVal.height += 10;
        // Mermaid 기본 정렬 (홈 화면에 적용)
        if (pre.classList.contains("tag-connection-define")) {
            let matrix = new DOMMatrix(window.getComputedStyle(pre).getPropertyValue('transform'));
            current.style.transform = matrix;
            pre.style.transform = 'unset';
        }
    });
</script>

<link rel="apple-touch-icon" sizes="180x180" href="/algorithm_with_boj/assets/images/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/algorithm_with_boj/assets/images/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/algorithm_with_boj/assets/images/icons/favicon-16x16.png">
<link rel="manifest" href="/algorithm_with_boj/assets/images/icons/site.webmanifest">
<link rel="mask-icon" href="/algorithm_with_boj/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;family=Noto+Sans+KR:wght@100..900&amp;display=swap" rel="stylesheet">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/algorithm_with_boj/">
  <img class="site-favicon" title="APSwBT" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/icons/favicon.ico" onerror="this.style.display='none'">
  APSwBT
</a>
</span><div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/algorithm_with_boj/">HOME</a><a class="page-link" href="/algorithm_with_boj/archives.html">POSTS</a><a class="page-link" href="/algorithm_with_boj/tags.html">TAGS</a>
          </div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(https://images.unsplash.com/photo-1460574283810-2aab119d8511?q=80&w=1463&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D);"></div>
        <img class="img-placeholder" src="https://images.unsplash.com/photo-1460574283810-2aab119d8511?q=80&w=1463&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">퍼시스턴트 세그먼트 트리</h1>
  <h2 class="post-subtitle">Persistent Segment Tree</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2024-01-30T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 30, 2024
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> CHOYUNSIG</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 28 mins</span>
  </div>
<div class="post-tags">
<a class="post-tag" href="/algorithm_with_boj/tags.html#%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0(data_structures)">#자료_구조(data_structures)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%ED%8A%B8%EB%A6%AC(trees)">#트리(trees)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8_%ED%8A%B8%EB%A6%AC(segtree)">#세그먼트_트리(segtree)</a><a class="post-tag" href="/algorithm_with_boj/tags.html#%ED%8D%BC%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8_%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8_%ED%8A%B8%EB%A6%AC(pst)">#퍼시스턴트_세그먼트_트리(pst)</a>
</div></header>
</div>
      <script>
        document.addEventListener('DOMContentLoaded', function () {
          var pageBannerInner = document.querySelector('.page-banner-inner');

          window.addEventListener('scroll', function () {
            pageBannerInner.style.opacity = Math.max((0.26 * window.innerHeight - window.scrollY) / (0.25 * window.innerHeight), 0);
          });
        });
      </script>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = window.scrollY + element.getBoundingClientRect().top - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<div class="post-related">
      <div>이전 포스트</div>
      <ul>
        
        
        <li class="">
          <a class="post-link" href="/algorithm_with_boj/post/2024/01/11/segtree.html" title="세그먼트 트리, 구간 트리">
            세그먼트 트리, 구간 트리
            
          </a>
        </li>
      </ul>
    </div>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="post-content e-content" itemprop="articleBody">

    <h2 id="소개">소개</h2>

<p>퍼시스턴트 세그먼트 트리란 매 수정 쿼리마다 트리의 상태를 덮어쓰지 않고 모두 저장하고 있는 세그먼트 트리를 말한다. 이러한 특성 때문에 퍼시스턴트 세그먼트 트리는 주로 2차원 상에서의 세그먼트 트리를 구현하기 위해서 많이 쓰인다.</p>

<h2 id="원리">원리</h2>

<p>아래와 같이 크기가 8인 배열을 관리하는 세그먼트 트리에서 3번 인덱스의 값을 바꾸는 연산을 수행할 것이다. 기존의 세그먼트 트리는 3번 인덱스를 가리키는 리프 정점의 모든 조상 정점의 값을 갱신해주었다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8

    A(0 ~ 7):::red
    B1(0 ~ 3):::red
    B2(4 ~ 7)
    C1(0 ~ 1)
    C2(2 ~ 3):::red
    C3(4 ~ 5)
    C4(6 ~ 7)
    D1(0)
    D2(1)
    D3(2)
    D4(3):::red
    D5(4)
    D6(5)
    D7(6)
    D8(7)

    classDef red stroke:#F00, fill:#FEE
</pre>

<p>하지만 퍼시스턴트 세그먼트 트리는 정점의 값을 수정하지 않는다. 퍼시스턴트 세그먼트 트리에서는 새로운 값을 지닌 정점을 새로 만들어 연결해준다. 우선 새로운 루트 정점을 생성하고 3번 인덱스를 가리키는 리프 정점까지 새로운 값으로 만들어준다. 그 후 만들어준 정점들과 기존에 있던 정점들을 대응되는 자리에 연결해준다.</p>

<div style="column-count: 2">
    <pre class="mermaid">
        graph TD

        A --&gt; B1
        B1 --&gt; C2
        C2 --&gt; D4

        A(0 ~ 7):::green
        B1(0 ~ 3):::green
        C2(2 ~ 3):::green
        D4(3):::green

        classDef green stroke:#0F0, fill:#EFE
    </pre>
    <pre class="mermaid">
        graph TD

        A --&gt; B1
        A --&gt; B2
        B1 --&gt; C1
        B1 --&gt; C2
        C2 --&gt; D3
        C2 --&gt; D4

        A(0 ~ 7):::green
        B1(0 ~ 3):::green
        B2(4 ~ 7)
        C1(0 ~ 1)
        C2(2 ~ 3):::green
        D3(2)
        D4(3):::green

        classDef green stroke:#0F0, fill:#EFE
    </pre>
</div>

<p>이 결과 세그먼트 트리의 루트 정점이 두 개가 된다. 하나는 인덱스 수정 쿼리가 처리되기 전의 루트이며, 다른 하나는 쿼리 처리 후의 루트이다. 각각의 루트 정점을 통해서 우리는 세그먼트 트리의 쿼리 처리 전의 상태와 처리 후의 상태를 모두 들여다볼 수 있게 되었다.</p>

<pre class="mermaid">
    graph TD

    A --&gt; B1
    A --&gt; B2
    B1 --&gt; C1
    B1 --&gt; C2
    B2 --&gt; C3
    B2 --&gt; C4
    C1 --&gt; D1
    C1 --&gt; D2
    C2 --&gt; D3
    C2 --&gt; D4
    C3 --&gt; D5
    C3 --&gt; D6
    C4 --&gt; D7
    C4 --&gt; D8
    A_mod --&gt; B1_mod
    A_mod --&gt; B2
    B1_mod --&gt; C1
    B1_mod --&gt; C2_mod
    C2_mod --&gt; D3
    C2_mod --&gt; D4_mod

    A(0 ~ 7)
    B1(0 ~ 3)
    B2(4 ~ 7)
    C1(0 ~ 1)
    C2(2 ~ 3)
    C3(4 ~ 5)
    C4(6 ~ 7)
    D1(0)
    D2(1)
    D3(2)
    D4(3)
    D5(4)
    D6(5)
    D7(6)
    D8(7)
    A_mod(0 ~ 7):::green
    B1_mod(0 ~ 3):::green
    C2_mod(2 ~ 3):::green
    D4_mod(3):::green
    A:::root
    A_mod:::root

    subgraph 수정 전
        A
        B1
        B2
        C1
        C2
        C3
        C4
        D1
        D2
        D3
        D4
        D5
        D6
        D7
        D8
    end

    subgraph 수정 후
        A_mod
        B1_mod
        C2_mod
        D4_mod
    end

    classDef green stroke:#0F0, fill:#EFE
    classDef root stroke:#F00, stroke-width:3px
</pre>

<h2 id="구현">구현</h2>

<p>어떠한 시점에서의 구간 합을 구해주는 퍼시스턴트 세그먼트 트리를 구현해보자. 퍼시스턴트 세그먼트 트리의 구현은 기존의 세그먼트 트리에서 인덱스 수정 함수의 메커니즘을 바꾼 것이다. 퍼시스턴트 세그먼트 트리에서는 루트 정점이 여러개가 발생하기 때문에 이를 관리해주는 배열을 선언할 필요가 있다. 우선 기존 세그먼트 트리의 정점 클래스에서 생성자 및 구간 합 함수는 그대로 가져온다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>그 후 인덱스 수정 함수에는 정점 자신의 값을 수정하는 대신에, 새로 만든 정점에 자식들을 연결시키고 값을 수정해준 뒤 완성된 정점을 반환하는 방식으로 바꿔주면 된다. 이 함수를 호출하면 인덱스 수정 쿼리가 처리된 후의 상태를 가진 루트 정점이 반환이 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Node:
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">:</span>
        <span class="c1"># 새로운 정점 생성
</span>        <span class="n">new_node</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">([</span><span class="n">value</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="c1"># 재귀 및 기존 정점와 연결
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="c1"># 자신의 값을 수정하는 대신 새로 만든 정점의 값을 수정해줌
</span>            <span class="n">new_node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">new_node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">new_node</span>
</code></pre></div></div>

<p>아래는 위에서 완성한 세그먼트 트리의 정점 클래스를 외부 클래스로 한 번 더 감싸 구현을 완료한 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="n">Node</span> <span class="ow">or</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>

        <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">SegmentTree.Node</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">([</span><span class="n">value</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">left</span>
                    <span class="n">new_node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="n">new_node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">new_node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span>
            <span class="k">return</span> <span class="n">new_node</span>

    <span class="c1"># 생성자
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="n">SegmentTree</span><span class="p">.</span><span class="nc">Node</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">))]</span>

    <span class="c1"># 구간 쿼리, 시점 t를 같이 입력받음
</span>    <span class="k">def</span> <span class="nf">get_sum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="nf">get_sum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># 원소 갱신
</span>    <span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">modify</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>

</code></pre></div></div>

<p>위 클래스 인스턴스에서 구간 합을 구하는 함수 <code class="language-plaintext highlighter-rouge">get_sum</code>에 시점 <code class="language-plaintext highlighter-rouge">t</code>를 같이 입력하여 해당 시점에서의 구간 합을 구할 수 있다.</p>

<h2 id="응용">응용</h2>

<p>퍼시스턴트 세그먼트 트리를 사용하면 다음 문제를 풀 수 있다.</p>

<blockquote>
  <p>$xy$ 평면에 여러 점들이 있다. 점들의 좌표는 모두 정수이다. 이에 다음 명령을 처리하는 프로그램을 작성하시오.</p>

  <p><code class="language-plaintext highlighter-rouge">x1 y1 x2 y2</code>: $\lbrace \left(x, y\right) |$<code class="language-plaintext highlighter-rouge">x1</code>$\le x &lt;$<code class="language-plaintext highlighter-rouge">x2</code>$\land$<code class="language-plaintext highlighter-rouge">y1</code>$\le y &lt;$<code class="language-plaintext highlighter-rouge">y2</code>$\rbrace$ 영역에 속하는 점의 개수를 출력한다.</p>
</blockquote>

<pre class="mermaid" style="background-color: white">
    quadrantChart
        title xy
        x-axis x
        y-axis y
        4,3: [0.4, 0.3]
        3,8: [0.3, 0.8]
        2,6: [0.2, 0.6]
        8,7: [0.8, 0.7]
        6,5: [0.6, 0.5]
        7,1: [0.7, 0.1]
        5,6: [0.5, 0.6]
</pre>

<p>주어진 평면의 $x$축을 시간축으로 보자. $y$축 크기만큼의 배열을 퍼시스턴트 세그먼트 트리로 관리하며 처음($t=0$)에는 배열의 값을 전부 0으로 초기화한다. 점들을 시간($x$ 좌표값)순으로 나열하고 이 순서대로 점들의 $y$ 좌표에 해당하는 인덱스에 더하기 1을 해준다. 위의 예시의 경우 7개의 점에 대해 각각 $t$번째 점마다 트리에 다음과 같은 상태들이 저장될 것이다.</p>

<p><img class="post-image" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/posts/pst-1.png" style="background-color: white"></p>

<table>
  <thead>
    <tr>
      <th>$y$</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$t=0$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=1$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=2$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=3$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=4$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td> </td>
      <td>2</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=5$</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td>2</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=6$</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td>2</td>
      <td> </td>
      <td>1</td>
      <td> </td>
    </tr>
    <tr>
      <td>$t=7$</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td> </td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>이렇게 관리를 하게 되면 시점 $t$에서의 $\left[l, r\right)$ 범위의 구간 합은 $x$ 좌표값 순으로 $t$번째의 점과 그 왼쪽에 있는 점들 중에서 $y$ 좌표가 $\left[l, r\right)$ 범위 안에 있는 모든 점들의 개수가 된다. 예시로, $t=6$에서의 $\left[4, 8\right)$ 범위의 구간 합은 다음 그림의 빨간 영역에 걸쳐있는 점의 개수이다.</p>

<p><img class="post-image" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/posts/pst-2.png" style="background-color: white"></p>

<p>이제 이 퍼시스턴트 세그먼트 트리를 바탕으로 쿼리를 처리해보자. <code class="language-plaintext highlighter-rouge">3 4 7 8</code>의 답은 무엇일까? $x$ 좌표가 $\left[3, 7\right)$ 범위에 속해있는 점들 중 $x$ 좌표값 순으로 가장 뒤에 있는 점은 $(6, 5)$(5번째 점)이다. 그리고 $x$ 좌표가 $\left[3, 7\right)$ 범위의 왼쪽, 즉 3보다 작은 점들 중 $x$ 좌표값 순으로 가장 뒤에 있는 점은 $(2, 6)$(1번째 점)이다. 따라서 정답은 시점 $t=5$에서의 $\left[4, 8\right)$ 구간 합에서 시점 $t=1$에서의 $\left[4, 8\right)$ 구간 합을 뺌으로서 구할 수 있다.</p>

<p><img class="post-image" src="https://choyunsig.github.io/algorithm_with_boj/assets/images/posts/pst-3.png" style="background-color: white"></p>

<p>퍼시스턴트 세그먼트 트리를 이용하면 위 문제의 명령을 $O(\log N)$의 시간복잡도로 해결할 수 있다.</p>


  </div>

  <script>
    // h2 태그를 제목으로 하고 있는 본문을 div로 묶음
    var postContentDiv = document.querySelector('div.post-content');
    var divContainer = [];

    while (postContentDiv.children.length > 0) {
      var currentElement = postContentDiv.children[0];
      if (currentElement.tagName.toLowerCase() === 'h2') {
        var newDiv = document.createElement('div');
        newDiv.classList.add('post-section');
        divContainer.push(newDiv);
      }
      divContainer[divContainer.length - 1].appendChild(currentElement);
    }

    for (var i = 0; i < divContainer.length; i++) {
      postContentDiv.appendChild(divContainer[i]);
    }
  </script>

  <script>
    // 포스트 내 테이블의 overflow 방지 및 margin 추가
    var postContentDiv = document.querySelector('div.post-content');
    var tables = postContentDiv.querySelectorAll('table');
    tables.forEach(function(table) {
      var div = document.createElement('div');
      div.classList.add('post-table');
      table.parentNode.replaceChild(div, table);
      div.appendChild(table);
    });
  </script><script>/*
    터치 스크롤 적용

    사용:
    Liquid 용법으로 사용됨
    include touch-scroller.html container="element.class"

    주의사항:
    터치 스크롤을 적용하려는 요소와 그것을 감싼 Container 요소가 반드시 직계 부모-자식 관계여야 함
    부모의 padding 값은 px 단위로 지정되어야 함
    자식의 overflow 값이 hidden으로 지정되어야 함
    */

    try {
        let scrollBefore = { translateX: 0, translateY: 0 };
        let scrollTarget = undefined;
        let scrollStart = { x: 0, y: 0 };
        let scrolling = false;
        let scrolled = false;

        function getPos(event) {
            var x = event.clientX;
            var y = event.clientY;
            if (x === undefined || y === undefined) {
                x = event.changedTouches[0].clientX;
                y = event.changedTouches[0].clientY;
            }
            return { 'x': x, 'y': y };
        }

        function onScrollStart(event) {
            const target = event.target.closest('pre.highlight');
            if (!target)
                return false;
            event.stopPropagation();
            scrollStart = getPos(event);
            var matrix = new DOMMatrix(window.getComputedStyle(target.children[0]).getPropertyValue('transform'));
            if (matrix === "none")
                matrix = new DOMMatrix('matrix(1, 0, 0, 1, 0, 0)');
            scrollBefore.translateX = matrix.m41;
            scrollBefore.translateY = matrix.m42;
            scrollTarget = target.children[0];
            scrolling = true;
            scrolled = false;
        }

        function onScrollMove(event) {
            if (!scrolling)
                return false;
            const pos = getPos(event);
            const style = window.getComputedStyle(scrollTarget.parentElement);
            let padX = parseFloat(style.getPropertyValue('padding-right')) + parseFloat(style.getPropertyValue('padding-right'));
            let padY = parseFloat(style.getPropertyValue('padding-top')) + parseFloat(style.getPropertyValue('padding-bottom'));
            const translateX = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().width - scrollTarget.parentElement.getBoundingClientRect().width + padX), Math.min(0, scrollBefore.translateX - (scrollStart.x - pos.x)));
            const translateY = Math.max(-Math.max(0, scrollTarget.getBoundingClientRect().height - scrollTarget.parentElement.getBoundingClientRect().height + padY), Math.min(0, scrollBefore.translateY - (scrollStart.y - pos.y)));
            if (!scrolled && (translateX - scrollBefore.translateX) ** 2 + (translateY - scrollBefore.translateY) ** 2 < 1) {
                scrolling = false;
                return;
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            scrollTarget.style.transform = `translate(${translateX}px, ${translateY}px)`;
            scrolled = true;
        }

        function onScrollEnd(event) {
            event.stopPropagation();
            scrolling = false;
            scrolled = false;
        }

        function onClick(event) {
            if (scrolled)
                event.preventDefault();
            return false;
        }
    }
    catch {
        // 두 번 이상 include 할 경우 여기에 표시
    }

    document.querySelectorAll('pre.highlight').forEach( pre => {
        pre.addEventListener("click", onClick);
        pre.addEventListener("mousedown", onScrollStart);
        pre.addEventListener("touchstart", onScrollStart);
        pre.addEventListener("touchmove", onScrollMove);
        pre.addEventListener("touchend", onScrollEnd);
    });
    window.addEventListener("mousemove", onScrollMove);
    window.addEventListener("mouseup", onScrollEnd);
</script></article>
<div class="post-related">
      <div>다음 포스트</div>
      <ul>
        
        
        <div>없음</div>
        
      </ul>
    </div>
  </section>
</div>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">Index</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 50;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/algorithm_with_boj/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Made by <a href="https://github.com/CHOYUNSIG">CHOYUNSIG</a>
</div>
      <div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>
</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/algorithm_with_boj/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
