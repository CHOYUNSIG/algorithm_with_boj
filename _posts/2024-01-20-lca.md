---
layout: post
title: 최소 공통 조상(Lowest Common Ancestor)
subtitle: 트리의 어떤 두 노드와 가장 가까운 공통 조상을 찾는 문제
author: CHOYUNSIG
categories: post
banner:
  video: null
  loop: true
  volume: 0
  start_at: 0
  image: https://images.unsplash.com/photo-1542361345-89e58247f2d5?q=80&w=1470&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D
  opacity: 1.0
  background: "rgba(0, 0, 0, 0.8)"
  height: null
  min_height: null
  heading_style: null
  subheading_style: null
tags: 트리(trees) 오일러_경로_테크닉(euler_tour_technique) 최소_공통_조상(lca)
sidebar: null
---

## 소개

최소 공통 조상 문제는 트리의 임의의 두 노드의 조상 노드이면서 두 노드로부터의 거리가 가장 가까운 노드를 찾는 문제이다. 최소 공통 조상 문제는 트리 상의 임의의 두 노드의 경로를 탐색하는 데에 쓰일 수 있다.

## 해결

최소 공통 조상을 찾기 위해서 우리는 단순히 두 노드에서부터 출발해 만날때까지 하나씩 올라오는 방법을 생각해 볼 수 있다. 하지만 이 방법은 크기가 $N$인 트리에서 $O(N)$의 시간복잡도를 가질 수 있어 적절하지 않다. 우리는 이 문제를 더 빠른 방법으로 해결해 볼 것이며 대표적으로 아래 두 방법이 존재한다.

### 다이나믹 프로그래밍

이 방식의 메인 아이디어는 조상 노드들을 탐색할 때 이분 탐색하듯이 거슬러 올라가도록 만드는 것이다. 우선 트리를 전처리한다. 트리 전체를 순회하면서 각 노드마다 깊이 정보와 함께 $2^n \left(n = 0, 1, 2 ...\right)$번째 조상 노드들을 저장해둘 것이다.

<pre class="mermaid">
    graph TD

    A --> B1
    A --> B2
    B1 --> C1
    B1 --> C2
    B1 --> C3
    C1 --> D1
    C1 --> D2
    D2 --> E1
    D2 --> E2
    E1 --> F1

    A(( ))
    B1(( )):::green
    B2(( ))
    C1(( ))
    C2(( ))
    C3(( ))
    D1(( ))
    D2(( )):::green
    E1(( )):::green
    E2(( ))
    F1(( )):::red

    classDef red stroke:#F00, fill:#FEE
    classDef green stroke:#0F0, fill:#EFE
</pre>

위 트리를 예시로 들어보자. 트리의 맨 아래 노드는 깊이가 5이고(루트의 깊이는 0이다) $2^0$, $2^1$, $2^2$번째 조상이 존재하므로 노드에 이 정보를 저장해 둔다. 모든 노드가 이러한 정보를 저장하고 있다면 최소 공통 조상 문제를 빠르게 풀 수 있다.

크기가 $N$인 트리의 임의의 노드 $\text A$와 $\text B$의 최소 공통 조상 $\text C$를 찾아가는 상황을 생각해보자. 트리는 위 예시처럼 전처리가 되어 있으며, 노드 $\text A$의 깊이가 더 크고 노드 $\text A$와 $\text C$ 경로 사이에 노드 $\text B$와 깊이가 같은 노드 $\text A'$이 있다고 하자. 도식화하면 아래 그림과 같으며 다른 노드는 생략하였다.

<pre class="mermaid">
    graph RL

    root --> C
    C --> Ap
    Ap -- <p style="color: #888">d</p> --> A
    C --> B

    root((Root))
    A((A))
    Ap((A'))
    B((B))
    C((C))
</pre>

우선 노드 $\text A$에서부터 노드 $\text B$와 깊이가 같은 노드인 $\text A'$까지 거슬러 올라온다. 그러기 위해서 거슬러 올라가야 하는 거리인 $d$를 구한다. 이는 간단히 노드 $\text A$의 깊이에서 노드 $\text B$의 깊이를 뺀 값이다. 예시로 $d = 13$이라고 해보자. 이는 다음과 같이 표현할 수 있다.

$$
d = 13 = 1011_{2} = 2^3 + 2^1 + 2^0
$$

우리는 앞서 모든 노드의 $2^n$번째 조상 노드를 구해놓았으므로 다음과 같은 경로로 노드 $\text A$에서 노드 $\text A'$로 갈 수 있다.

<pre class="mermaid">
    graph LR

    A -. <p style="color: #888">2<sup>3</sup></p> .-> node1
    node1 -. <p style="color: #888">2<sup>1</sup></p> .-> node2
    node2 -. <p style="color: #888">2<sup>0</sup></p> .-> Ap

    A((A))
    Ap((A'))
    node1(( ))
    node2(( ))
</pre>

즉, 노드 $\text A$에서 노드 $\text A'$로 가는 데 $O(\log N)$의 시간이 든다. 이제 노드 $\text A'$과 $\text B$에서 동시에 $\text C$를 향해 올라온다. 거슬러 올라갈 조상 노드를 선택할 떄는 $\text C$를 넘어서서 거슬러 올라가지 않으면서 가장 멀리 갈 수 있는 노드를 선택하면 된다. 이를 수학적으로 표현하면, 다음을 집합의 최댓값 $m$에 대해 $2^m$번째 조상으로 계속해서 거슬러 올라가는 과정을 반복하면 된다.

$$
\lbrace 0 \rbrace \cap \lbrace k | \text 2^k\text{번째 조상이 같지 않음}\rbrace
$$

<pre class="mermaid">
    graph TD

    subgraph O
        direction LR
        Ap1 -. <p style="color: #888">2<sup>k</sup></p> .-> node1
        B1 -. <p style="color: #888">2<sup>k</sup></p> .-> node2
        node1 -.-> C1
        node2 -.-> C1
        C1 -.-> root1
    end

    subgraph X
        direction LR
        Ap2 -.-> C2
        B2 -.-> C2
        Ap2 -. <p style="color: #888">2<sup>k+1</sup></p> .-> node3
        C2 -.-> node3
        B2 -. <p style="color: #888">2<sup>k+1</sup></p> .-> node3
        node3 -.-> root2
    end

    Ap1((A'))
    Ap2((A'))
    B1((B))
    B2((B))
    C1((C))
    C2((C))
    root1((Root))
    root2((Root))
    node1(( ))
    node2(( ))
    node3(( ))
</pre>

위 과정을 반복하면 최소 공통 조상인 노드 $\text C$에서 만나게 될 것이다. 이 과정 역시 $O(\log N)$의 시간이 든다. 따라서 다이나믹 프로그래밍 기법을 사용한 최소 공통 조상 문제 풀이의 시간복잡도는 $O(\log N)$이다.

### 오일러 경로 테크닉

<a href="../../../2024/01/18/euler_tour_technique.html">오일러 경로 테크닉</a>이란 트리의 DFS 방문 순서대로 노드들을 나열하여 트리를 선형적으로 관리하는 기법이다. 오일러 경로 테크닉을 이용한 최소 공통 조상 문제의 풀이는 어떠한 노드 $\text A$와 $\text B$ 사이의 최소 공통 조상은 DFS 방문 순서상 노드 $\text A$와 $\text B$ 사이에서 반드시 재방문하게 됨을 이용한다.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Stirling_permutation_Euler_tour.svg/306px-Stirling_permutation_Euler_tour.svg.png" style="background-color: white">

최소 공통 조상 문제를 풀기 위해서는 정점에 번호를 매기는 방법을 조금 다르게 한다. 우선 빈 배열을 하나 생성한 뒤 DFS를 수행하면서 재방문을 포함해 정점에 방문할 때마다 해당 노드를 배열의 끝에 추가한다. 그리고 각 노드에는 깊이와 함께 배열에서 첫 번째와 마지막으로 등장하는 인덱스 번호를 저장한다. 아래 예시를 보자.

<pre class="mermaid">
    graph TD
    A --> B
    A --> C
    A --> D
    B --> E
    B --> F
    E --> G

    A((A))
    B((B))
    C((C))
    D((D))
    E((E))
    F((F))
    G((G))
</pre>

$$
\text{Array: }\left[\text{A,  B,  E,  G,  E,  B,  F,  B,  A,  C,  A,  D,  A}\right]
$$

|                       | $\text A$ | $\text B$ | $\text C$ | $\text D$ | $\text E$ | $\text F$ | $\text G$ |
| ---                   | ---       | ---       | ---       | ---       | ---       | ---       | ---       |
| Depth                 | 0         | 1         | 1         | 1         | 2         | 2         | 3         |
| index<sub>start</sub> | 0         | 1         | 9         | 11        | 2         | 6         | 3         |
| index<sub>end</sub>   | 12        | 7         | 9         | 11        | 4         | 6         | 3         |

이 상황에서 노드 $\text F$와 $\text G$의 최소 공통 조상을 찾아보자. 배열 상에서 노드 $\text F$나 $\text G$가 처음 등장하는 인덱스는 3, 가장 마지막으로 등장하는 인덱스는 6이다. 따라서 인덱스 3과 6 사이에 있는 노드들 중에서 깊이가 가장 작은 노드인 $\text B$가 이 두 노드의 최소 공통 조상이다.

$$
\text{A,  B,  E, }\left[\text{G,  E,  B,  F}\right]\text{,  B,  A,  C,  A,  D,  A}
$$

<pre class="mermaid">
    graph TD
    A --> B
    A --> C
    A --> D
    B --> E
    B --> F
    E --> G

    A((A))
    B((B)):::red
    C((C))
    D((D))
    E((E)):::red
    F((F)):::red
    G((G)):::red

    classDef red stroke:#F00, fill:#FEE
</pre>

이는 구간 최솟값 쿼리로 이해할 수 있으므로 세그먼트 트리를 사용하여 $O(\log N)$의 시간만에 문제를 해결할 수 있다.